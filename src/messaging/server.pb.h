// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_server_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_server_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_server_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_server_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_server_2eproto;
namespace server {
class Creature;
struct CreatureDefaultTypeInternal;
extern CreatureDefaultTypeInternal _Creature_default_instance_;
class CreatureName;
struct CreatureNameDefaultTypeInternal;
extern CreatureNameDefaultTypeInternal _CreatureName_default_instance_;
class Creature_Motor;
struct Creature_MotorDefaultTypeInternal;
extern Creature_MotorDefaultTypeInternal _Creature_Motor_default_instance_;
class DatabaseInfo;
struct DatabaseInfoDefaultTypeInternal;
extern DatabaseInfoDefaultTypeInternal _DatabaseInfo_default_instance_;
}  // namespace server
PROTOBUF_NAMESPACE_OPEN
template<> ::server::Creature* Arena::CreateMaybeMessage<::server::Creature>(Arena*);
template<> ::server::CreatureName* Arena::CreateMaybeMessage<::server::CreatureName>(Arena*);
template<> ::server::Creature_Motor* Arena::CreateMaybeMessage<::server::Creature_Motor>(Arena*);
template<> ::server::DatabaseInfo* Arena::CreateMaybeMessage<::server::DatabaseInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace server {

enum Creature_MotorType : int {
  Creature_MotorType_SERVO = 0,
  Creature_MotorType_STEPPER = 1,
  Creature_MotorType_Creature_MotorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Creature_MotorType_Creature_MotorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Creature_MotorType_IsValid(int value);
constexpr Creature_MotorType Creature_MotorType_MotorType_MIN = Creature_MotorType_SERVO;
constexpr Creature_MotorType Creature_MotorType_MotorType_MAX = Creature_MotorType_STEPPER;
constexpr int Creature_MotorType_MotorType_ARRAYSIZE = Creature_MotorType_MotorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Creature_MotorType_descriptor();
template<typename T>
inline const std::string& Creature_MotorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Creature_MotorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Creature_MotorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Creature_MotorType_descriptor(), enum_t_value);
}
inline bool Creature_MotorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Creature_MotorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Creature_MotorType>(
    Creature_MotorType_descriptor(), name, value);
}
// ===================================================================

class DatabaseInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.DatabaseInfo) */ {
 public:
  inline DatabaseInfo() : DatabaseInfo(nullptr) {}
  ~DatabaseInfo() override;
  explicit PROTOBUF_CONSTEXPR DatabaseInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatabaseInfo(const DatabaseInfo& from);
  DatabaseInfo(DatabaseInfo&& from) noexcept
    : DatabaseInfo() {
    *this = ::std::move(from);
  }

  inline DatabaseInfo& operator=(const DatabaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatabaseInfo& operator=(DatabaseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatabaseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatabaseInfo* internal_default_instance() {
    return reinterpret_cast<const DatabaseInfo*>(
               &_DatabaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DatabaseInfo& a, DatabaseInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DatabaseInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatabaseInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatabaseInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatabaseInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatabaseInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatabaseInfo& from) {
    DatabaseInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatabaseInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.DatabaseInfo";
  }
  protected:
  explicit DatabaseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kHelpFieldNumber = 2,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string help = 2;
  void clear_help();
  const std::string& help() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_help(ArgT0&& arg0, ArgT... args);
  std::string* mutable_help();
  PROTOBUF_NODISCARD std::string* release_help();
  void set_allocated_help(std::string* help);
  private:
  const std::string& _internal_help() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_help(const std::string& value);
  std::string* _internal_mutable_help();
  public:

  // @@protoc_insertion_point(class_scope:server.DatabaseInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr help_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class CreatureName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.CreatureName) */ {
 public:
  inline CreatureName() : CreatureName(nullptr) {}
  ~CreatureName() override;
  explicit PROTOBUF_CONSTEXPR CreatureName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatureName(const CreatureName& from);
  CreatureName(CreatureName&& from) noexcept
    : CreatureName() {
    *this = ::std::move(from);
  }

  inline CreatureName& operator=(const CreatureName& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatureName& operator=(CreatureName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatureName& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatureName* internal_default_instance() {
    return reinterpret_cast<const CreatureName*>(
               &_CreatureName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreatureName& a, CreatureName& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatureName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatureName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatureName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatureName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatureName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreatureName& from) {
    CreatureName::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatureName* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.CreatureName";
  }
  protected:
  explicit CreatureName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:server.CreatureName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class Creature_Motor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.Creature.Motor) */ {
 public:
  inline Creature_Motor() : Creature_Motor(nullptr) {}
  ~Creature_Motor() override;
  explicit PROTOBUF_CONSTEXPR Creature_Motor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Creature_Motor(const Creature_Motor& from);
  Creature_Motor(Creature_Motor&& from) noexcept
    : Creature_Motor() {
    *this = ::std::move(from);
  }

  inline Creature_Motor& operator=(const Creature_Motor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Creature_Motor& operator=(Creature_Motor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Creature_Motor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Creature_Motor* internal_default_instance() {
    return reinterpret_cast<const Creature_Motor*>(
               &_Creature_Motor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Creature_Motor& a, Creature_Motor& b) {
    a.Swap(&b);
  }
  inline void Swap(Creature_Motor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Creature_Motor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Creature_Motor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Creature_Motor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Creature_Motor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Creature_Motor& from) {
    Creature_Motor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Creature_Motor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.Creature.Motor";
  }
  protected:
  explicit Creature_Motor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kNumberFieldNumber = 2,
    kMaxValueFieldNumber = 3,
    kMinValueFieldNumber = 4,
    kSmoothingValueFieldNumber = 5,
  };
  // .server.Creature.MotorType type = 1;
  void clear_type();
  ::server::Creature_MotorType type() const;
  void set_type(::server::Creature_MotorType value);
  private:
  ::server::Creature_MotorType _internal_type() const;
  void _internal_set_type(::server::Creature_MotorType value);
  public:

  // uint32 number = 2;
  void clear_number();
  uint32_t number() const;
  void set_number(uint32_t value);
  private:
  uint32_t _internal_number() const;
  void _internal_set_number(uint32_t value);
  public:

  // uint32 max_value = 3;
  void clear_max_value();
  uint32_t max_value() const;
  void set_max_value(uint32_t value);
  private:
  uint32_t _internal_max_value() const;
  void _internal_set_max_value(uint32_t value);
  public:

  // uint32 min_value = 4;
  void clear_min_value();
  uint32_t min_value() const;
  void set_min_value(uint32_t value);
  private:
  uint32_t _internal_min_value() const;
  void _internal_set_min_value(uint32_t value);
  public:

  // float smoothing_value = 5;
  void clear_smoothing_value();
  float smoothing_value() const;
  void set_smoothing_value(float value);
  private:
  float _internal_smoothing_value() const;
  void _internal_set_smoothing_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:server.Creature.Motor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    uint32_t number_;
    uint32_t max_value_;
    uint32_t min_value_;
    float smoothing_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class Creature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.Creature) */ {
 public:
  inline Creature() : Creature(nullptr) {}
  ~Creature() override;
  explicit PROTOBUF_CONSTEXPR Creature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Creature(const Creature& from);
  Creature(Creature&& from) noexcept
    : Creature() {
    *this = ::std::move(from);
  }

  inline Creature& operator=(const Creature& from) {
    CopyFrom(from);
    return *this;
  }
  inline Creature& operator=(Creature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Creature& default_instance() {
    return *internal_default_instance();
  }
  static inline const Creature* internal_default_instance() {
    return reinterpret_cast<const Creature*>(
               &_Creature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Creature& a, Creature& b) {
    a.Swap(&b);
  }
  inline void Swap(Creature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Creature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Creature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Creature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Creature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Creature& from) {
    Creature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Creature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.Creature";
  }
  protected:
  explicit Creature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Creature_Motor Motor;

  typedef Creature_MotorType MotorType;
  static constexpr MotorType SERVO =
    Creature_MotorType_SERVO;
  static constexpr MotorType STEPPER =
    Creature_MotorType_STEPPER;
  static inline bool MotorType_IsValid(int value) {
    return Creature_MotorType_IsValid(value);
  }
  static constexpr MotorType MotorType_MIN =
    Creature_MotorType_MotorType_MIN;
  static constexpr MotorType MotorType_MAX =
    Creature_MotorType_MotorType_MAX;
  static constexpr int MotorType_ARRAYSIZE =
    Creature_MotorType_MotorType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MotorType_descriptor() {
    return Creature_MotorType_descriptor();
  }
  template<typename T>
  static inline const std::string& MotorType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MotorType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MotorType_Name.");
    return Creature_MotorType_Name(enum_t_value);
  }
  static inline bool MotorType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MotorType* value) {
    return Creature_MotorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMotorsFieldNumber = 8,
    kNameFieldNumber = 1,
    kIdFieldNumber = 2,
    kSacnIpFieldNumber = 4,
    kLastUpdatedFieldNumber = 3,
    kUniverseFieldNumber = 5,
    kDmxBaseFieldNumber = 6,
    kNumberOfMotorsFieldNumber = 7,
  };
  // repeated .server.Creature.Motor motors = 8;
  int motors_size() const;
  private:
  int _internal_motors_size() const;
  public:
  void clear_motors();
  ::server::Creature_Motor* mutable_motors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor >*
      mutable_motors();
  private:
  const ::server::Creature_Motor& _internal_motors(int index) const;
  ::server::Creature_Motor* _internal_add_motors();
  public:
  const ::server::Creature_Motor& motors(int index) const;
  ::server::Creature_Motor* add_motors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor >&
      motors() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string sacn_ip = 4;
  void clear_sacn_ip();
  const std::string& sacn_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sacn_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sacn_ip();
  PROTOBUF_NODISCARD std::string* release_sacn_ip();
  void set_allocated_sacn_ip(std::string* sacn_ip);
  private:
  const std::string& _internal_sacn_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sacn_ip(const std::string& value);
  std::string* _internal_mutable_sacn_ip();
  public:

  // .google.protobuf.Timestamp last_updated = 3;
  bool has_last_updated() const;
  private:
  bool _internal_has_last_updated() const;
  public:
  void clear_last_updated();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_updated() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_updated();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_updated();
  void set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_updated() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_updated();
  public:
  void unsafe_arena_set_allocated_last_updated(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_updated();

  // uint32 universe = 5;
  void clear_universe();
  uint32_t universe() const;
  void set_universe(uint32_t value);
  private:
  uint32_t _internal_universe() const;
  void _internal_set_universe(uint32_t value);
  public:

  // uint32 dmx_base = 6;
  void clear_dmx_base();
  uint32_t dmx_base() const;
  void set_dmx_base(uint32_t value);
  private:
  uint32_t _internal_dmx_base() const;
  void _internal_set_dmx_base(uint32_t value);
  public:

  // uint32 number_of_motors = 7;
  void clear_number_of_motors();
  uint32_t number_of_motors() const;
  void set_number_of_motors(uint32_t value);
  private:
  uint32_t _internal_number_of_motors() const;
  void _internal_set_number_of_motors(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:server.Creature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor > motors_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sacn_ip_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated_;
    uint32_t universe_;
    uint32_t dmx_base_;
    uint32_t number_of_motors_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DatabaseInfo

// string message = 1;
inline void DatabaseInfo::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& DatabaseInfo::message() const {
  // @@protoc_insertion_point(field_get:server.DatabaseInfo.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatabaseInfo::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.DatabaseInfo.message)
}
inline std::string* DatabaseInfo::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:server.DatabaseInfo.message)
  return _s;
}
inline const std::string& DatabaseInfo::_internal_message() const {
  return _impl_.message_.Get();
}
inline void DatabaseInfo::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* DatabaseInfo::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* DatabaseInfo::release_message() {
  // @@protoc_insertion_point(field_release:server.DatabaseInfo.message)
  return _impl_.message_.Release();
}
inline void DatabaseInfo::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.DatabaseInfo.message)
}

// string help = 2;
inline void DatabaseInfo::clear_help() {
  _impl_.help_.ClearToEmpty();
}
inline const std::string& DatabaseInfo::help() const {
  // @@protoc_insertion_point(field_get:server.DatabaseInfo.help)
  return _internal_help();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatabaseInfo::set_help(ArgT0&& arg0, ArgT... args) {
 
 _impl_.help_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.DatabaseInfo.help)
}
inline std::string* DatabaseInfo::mutable_help() {
  std::string* _s = _internal_mutable_help();
  // @@protoc_insertion_point(field_mutable:server.DatabaseInfo.help)
  return _s;
}
inline const std::string& DatabaseInfo::_internal_help() const {
  return _impl_.help_.Get();
}
inline void DatabaseInfo::_internal_set_help(const std::string& value) {
  
  _impl_.help_.Set(value, GetArenaForAllocation());
}
inline std::string* DatabaseInfo::_internal_mutable_help() {
  
  return _impl_.help_.Mutable(GetArenaForAllocation());
}
inline std::string* DatabaseInfo::release_help() {
  // @@protoc_insertion_point(field_release:server.DatabaseInfo.help)
  return _impl_.help_.Release();
}
inline void DatabaseInfo::set_allocated_help(std::string* help) {
  if (help != nullptr) {
    
  } else {
    
  }
  _impl_.help_.SetAllocated(help, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.help_.IsDefault()) {
    _impl_.help_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.DatabaseInfo.help)
}

// -------------------------------------------------------------------

// CreatureName

// string name = 1;
inline void CreatureName::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreatureName::name() const {
  // @@protoc_insertion_point(field_get:server.CreatureName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatureName::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.CreatureName.name)
}
inline std::string* CreatureName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:server.CreatureName.name)
  return _s;
}
inline const std::string& CreatureName::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreatureName::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreatureName::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreatureName::release_name() {
  // @@protoc_insertion_point(field_release:server.CreatureName.name)
  return _impl_.name_.Release();
}
inline void CreatureName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.CreatureName.name)
}

// -------------------------------------------------------------------

// Creature_Motor

// .server.Creature.MotorType type = 1;
inline void Creature_Motor::clear_type() {
  _impl_.type_ = 0;
}
inline ::server::Creature_MotorType Creature_Motor::_internal_type() const {
  return static_cast< ::server::Creature_MotorType >(_impl_.type_);
}
inline ::server::Creature_MotorType Creature_Motor::type() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.type)
  return _internal_type();
}
inline void Creature_Motor::_internal_set_type(::server::Creature_MotorType value) {
  
  _impl_.type_ = value;
}
inline void Creature_Motor::set_type(::server::Creature_MotorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.type)
}

// uint32 number = 2;
inline void Creature_Motor::clear_number() {
  _impl_.number_ = 0u;
}
inline uint32_t Creature_Motor::_internal_number() const {
  return _impl_.number_;
}
inline uint32_t Creature_Motor::number() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.number)
  return _internal_number();
}
inline void Creature_Motor::_internal_set_number(uint32_t value) {
  
  _impl_.number_ = value;
}
inline void Creature_Motor::set_number(uint32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.number)
}

// uint32 max_value = 3;
inline void Creature_Motor::clear_max_value() {
  _impl_.max_value_ = 0u;
}
inline uint32_t Creature_Motor::_internal_max_value() const {
  return _impl_.max_value_;
}
inline uint32_t Creature_Motor::max_value() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.max_value)
  return _internal_max_value();
}
inline void Creature_Motor::_internal_set_max_value(uint32_t value) {
  
  _impl_.max_value_ = value;
}
inline void Creature_Motor::set_max_value(uint32_t value) {
  _internal_set_max_value(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.max_value)
}

// uint32 min_value = 4;
inline void Creature_Motor::clear_min_value() {
  _impl_.min_value_ = 0u;
}
inline uint32_t Creature_Motor::_internal_min_value() const {
  return _impl_.min_value_;
}
inline uint32_t Creature_Motor::min_value() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.min_value)
  return _internal_min_value();
}
inline void Creature_Motor::_internal_set_min_value(uint32_t value) {
  
  _impl_.min_value_ = value;
}
inline void Creature_Motor::set_min_value(uint32_t value) {
  _internal_set_min_value(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.min_value)
}

// float smoothing_value = 5;
inline void Creature_Motor::clear_smoothing_value() {
  _impl_.smoothing_value_ = 0;
}
inline float Creature_Motor::_internal_smoothing_value() const {
  return _impl_.smoothing_value_;
}
inline float Creature_Motor::smoothing_value() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.smoothing_value)
  return _internal_smoothing_value();
}
inline void Creature_Motor::_internal_set_smoothing_value(float value) {
  
  _impl_.smoothing_value_ = value;
}
inline void Creature_Motor::set_smoothing_value(float value) {
  _internal_set_smoothing_value(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.smoothing_value)
}

// -------------------------------------------------------------------

// Creature

// string name = 1;
inline void Creature::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Creature::name() const {
  // @@protoc_insertion_point(field_get:server.Creature.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Creature::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Creature.name)
}
inline std::string* Creature::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:server.Creature.name)
  return _s;
}
inline const std::string& Creature::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Creature::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Creature::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Creature::release_name() {
  // @@protoc_insertion_point(field_release:server.Creature.name)
  return _impl_.name_.Release();
}
inline void Creature::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Creature.name)
}

// string id = 2;
inline void Creature::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Creature::id() const {
  // @@protoc_insertion_point(field_get:server.Creature.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Creature::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Creature.id)
}
inline std::string* Creature::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:server.Creature.id)
  return _s;
}
inline const std::string& Creature::_internal_id() const {
  return _impl_.id_.Get();
}
inline void Creature::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Creature::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Creature::release_id() {
  // @@protoc_insertion_point(field_release:server.Creature.id)
  return _impl_.id_.Release();
}
inline void Creature::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Creature.id)
}

// .google.protobuf.Timestamp last_updated = 3;
inline bool Creature::_internal_has_last_updated() const {
  return this != internal_default_instance() && _impl_.last_updated_ != nullptr;
}
inline bool Creature::has_last_updated() const {
  return _internal_has_last_updated();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Creature::_internal_last_updated() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_updated_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Creature::last_updated() const {
  // @@protoc_insertion_point(field_get:server.Creature.last_updated)
  return _internal_last_updated();
}
inline void Creature::unsafe_arena_set_allocated_last_updated(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_updated_);
  }
  _impl_.last_updated_ = last_updated;
  if (last_updated) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:server.Creature.last_updated)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Creature::release_last_updated() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_updated_;
  _impl_.last_updated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Creature::unsafe_arena_release_last_updated() {
  // @@protoc_insertion_point(field_release:server.Creature.last_updated)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_updated_;
  _impl_.last_updated_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Creature::_internal_mutable_last_updated() {
  
  if (_impl_.last_updated_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_updated_ = p;
  }
  return _impl_.last_updated_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Creature::mutable_last_updated() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_updated();
  // @@protoc_insertion_point(field_mutable:server.Creature.last_updated)
  return _msg;
}
inline void Creature::set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_updated_);
  }
  if (last_updated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated));
    if (message_arena != submessage_arena) {
      last_updated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_updated, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_updated_ = last_updated;
  // @@protoc_insertion_point(field_set_allocated:server.Creature.last_updated)
}

// string sacn_ip = 4;
inline void Creature::clear_sacn_ip() {
  _impl_.sacn_ip_.ClearToEmpty();
}
inline const std::string& Creature::sacn_ip() const {
  // @@protoc_insertion_point(field_get:server.Creature.sacn_ip)
  return _internal_sacn_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Creature::set_sacn_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sacn_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Creature.sacn_ip)
}
inline std::string* Creature::mutable_sacn_ip() {
  std::string* _s = _internal_mutable_sacn_ip();
  // @@protoc_insertion_point(field_mutable:server.Creature.sacn_ip)
  return _s;
}
inline const std::string& Creature::_internal_sacn_ip() const {
  return _impl_.sacn_ip_.Get();
}
inline void Creature::_internal_set_sacn_ip(const std::string& value) {
  
  _impl_.sacn_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Creature::_internal_mutable_sacn_ip() {
  
  return _impl_.sacn_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* Creature::release_sacn_ip() {
  // @@protoc_insertion_point(field_release:server.Creature.sacn_ip)
  return _impl_.sacn_ip_.Release();
}
inline void Creature::set_allocated_sacn_ip(std::string* sacn_ip) {
  if (sacn_ip != nullptr) {
    
  } else {
    
  }
  _impl_.sacn_ip_.SetAllocated(sacn_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sacn_ip_.IsDefault()) {
    _impl_.sacn_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Creature.sacn_ip)
}

// uint32 universe = 5;
inline void Creature::clear_universe() {
  _impl_.universe_ = 0u;
}
inline uint32_t Creature::_internal_universe() const {
  return _impl_.universe_;
}
inline uint32_t Creature::universe() const {
  // @@protoc_insertion_point(field_get:server.Creature.universe)
  return _internal_universe();
}
inline void Creature::_internal_set_universe(uint32_t value) {
  
  _impl_.universe_ = value;
}
inline void Creature::set_universe(uint32_t value) {
  _internal_set_universe(value);
  // @@protoc_insertion_point(field_set:server.Creature.universe)
}

// uint32 dmx_base = 6;
inline void Creature::clear_dmx_base() {
  _impl_.dmx_base_ = 0u;
}
inline uint32_t Creature::_internal_dmx_base() const {
  return _impl_.dmx_base_;
}
inline uint32_t Creature::dmx_base() const {
  // @@protoc_insertion_point(field_get:server.Creature.dmx_base)
  return _internal_dmx_base();
}
inline void Creature::_internal_set_dmx_base(uint32_t value) {
  
  _impl_.dmx_base_ = value;
}
inline void Creature::set_dmx_base(uint32_t value) {
  _internal_set_dmx_base(value);
  // @@protoc_insertion_point(field_set:server.Creature.dmx_base)
}

// uint32 number_of_motors = 7;
inline void Creature::clear_number_of_motors() {
  _impl_.number_of_motors_ = 0u;
}
inline uint32_t Creature::_internal_number_of_motors() const {
  return _impl_.number_of_motors_;
}
inline uint32_t Creature::number_of_motors() const {
  // @@protoc_insertion_point(field_get:server.Creature.number_of_motors)
  return _internal_number_of_motors();
}
inline void Creature::_internal_set_number_of_motors(uint32_t value) {
  
  _impl_.number_of_motors_ = value;
}
inline void Creature::set_number_of_motors(uint32_t value) {
  _internal_set_number_of_motors(value);
  // @@protoc_insertion_point(field_set:server.Creature.number_of_motors)
}

// repeated .server.Creature.Motor motors = 8;
inline int Creature::_internal_motors_size() const {
  return _impl_.motors_.size();
}
inline int Creature::motors_size() const {
  return _internal_motors_size();
}
inline void Creature::clear_motors() {
  _impl_.motors_.Clear();
}
inline ::server::Creature_Motor* Creature::mutable_motors(int index) {
  // @@protoc_insertion_point(field_mutable:server.Creature.motors)
  return _impl_.motors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor >*
Creature::mutable_motors() {
  // @@protoc_insertion_point(field_mutable_list:server.Creature.motors)
  return &_impl_.motors_;
}
inline const ::server::Creature_Motor& Creature::_internal_motors(int index) const {
  return _impl_.motors_.Get(index);
}
inline const ::server::Creature_Motor& Creature::motors(int index) const {
  // @@protoc_insertion_point(field_get:server.Creature.motors)
  return _internal_motors(index);
}
inline ::server::Creature_Motor* Creature::_internal_add_motors() {
  return _impl_.motors_.Add();
}
inline ::server::Creature_Motor* Creature::add_motors() {
  ::server::Creature_Motor* _add = _internal_add_motors();
  // @@protoc_insertion_point(field_add:server.Creature.motors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor >&
Creature::motors() const {
  // @@protoc_insertion_point(field_list:server.Creature.motors)
  return _impl_.motors_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace server

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::server::Creature_MotorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server::Creature_MotorType>() {
  return ::server::Creature_MotorType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_server_2eproto
