// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_server_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_server_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_server_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_server_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_server_2eproto;
namespace server {
class Animation;
struct AnimationDefaultTypeInternal;
extern AnimationDefaultTypeInternal _Animation_default_instance_;
class AnimationFilter;
struct AnimationFilterDefaultTypeInternal;
extern AnimationFilterDefaultTypeInternal _AnimationFilter_default_instance_;
class AnimationId;
struct AnimationIdDefaultTypeInternal;
extern AnimationIdDefaultTypeInternal _AnimationId_default_instance_;
class AnimationIdentifier;
struct AnimationIdentifierDefaultTypeInternal;
extern AnimationIdentifierDefaultTypeInternal _AnimationIdentifier_default_instance_;
class Animation_Frame;
struct Animation_FrameDefaultTypeInternal;
extern Animation_FrameDefaultTypeInternal _Animation_Frame_default_instance_;
class Animation_Metadata;
struct Animation_MetadataDefaultTypeInternal;
extern Animation_MetadataDefaultTypeInternal _Animation_Metadata_default_instance_;
class Creature;
struct CreatureDefaultTypeInternal;
extern CreatureDefaultTypeInternal _Creature_default_instance_;
class CreatureFilter;
struct CreatureFilterDefaultTypeInternal;
extern CreatureFilterDefaultTypeInternal _CreatureFilter_default_instance_;
class CreatureId;
struct CreatureIdDefaultTypeInternal;
extern CreatureIdDefaultTypeInternal _CreatureId_default_instance_;
class CreatureIdentifier;
struct CreatureIdentifierDefaultTypeInternal;
extern CreatureIdentifierDefaultTypeInternal _CreatureIdentifier_default_instance_;
class CreatureName;
struct CreatureNameDefaultTypeInternal;
extern CreatureNameDefaultTypeInternal _CreatureName_default_instance_;
class Creature_Motor;
struct Creature_MotorDefaultTypeInternal;
extern Creature_MotorDefaultTypeInternal _Creature_Motor_default_instance_;
class DatabaseInfo;
struct DatabaseInfoDefaultTypeInternal;
extern DatabaseInfoDefaultTypeInternal _DatabaseInfo_default_instance_;
class Frame;
struct FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class FrameResponse;
struct FrameResponseDefaultTypeInternal;
extern FrameResponseDefaultTypeInternal _FrameResponse_default_instance_;
class GetAllCreaturesResponse;
struct GetAllCreaturesResponseDefaultTypeInternal;
extern GetAllCreaturesResponseDefaultTypeInternal _GetAllCreaturesResponse_default_instance_;
class ListAnimationsResponse;
struct ListAnimationsResponseDefaultTypeInternal;
extern ListAnimationsResponseDefaultTypeInternal _ListAnimationsResponse_default_instance_;
class ListCreaturesResponse;
struct ListCreaturesResponseDefaultTypeInternal;
extern ListCreaturesResponseDefaultTypeInternal _ListCreaturesResponse_default_instance_;
class LogFilter;
struct LogFilterDefaultTypeInternal;
extern LogFilterDefaultTypeInternal _LogFilter_default_instance_;
class LogItem;
struct LogItemDefaultTypeInternal;
extern LogItemDefaultTypeInternal _LogItem_default_instance_;
class PlayAnimationRequest;
struct PlayAnimationRequestDefaultTypeInternal;
extern PlayAnimationRequestDefaultTypeInternal _PlayAnimationRequest_default_instance_;
class PlayAnimationResponse;
struct PlayAnimationResponseDefaultTypeInternal;
extern PlayAnimationResponseDefaultTypeInternal _PlayAnimationResponse_default_instance_;
class ServerStatus;
struct ServerStatusDefaultTypeInternal;
extern ServerStatusDefaultTypeInternal _ServerStatus_default_instance_;
}  // namespace server
PROTOBUF_NAMESPACE_OPEN
template<> ::server::Animation* Arena::CreateMaybeMessage<::server::Animation>(Arena*);
template<> ::server::AnimationFilter* Arena::CreateMaybeMessage<::server::AnimationFilter>(Arena*);
template<> ::server::AnimationId* Arena::CreateMaybeMessage<::server::AnimationId>(Arena*);
template<> ::server::AnimationIdentifier* Arena::CreateMaybeMessage<::server::AnimationIdentifier>(Arena*);
template<> ::server::Animation_Frame* Arena::CreateMaybeMessage<::server::Animation_Frame>(Arena*);
template<> ::server::Animation_Metadata* Arena::CreateMaybeMessage<::server::Animation_Metadata>(Arena*);
template<> ::server::Creature* Arena::CreateMaybeMessage<::server::Creature>(Arena*);
template<> ::server::CreatureFilter* Arena::CreateMaybeMessage<::server::CreatureFilter>(Arena*);
template<> ::server::CreatureId* Arena::CreateMaybeMessage<::server::CreatureId>(Arena*);
template<> ::server::CreatureIdentifier* Arena::CreateMaybeMessage<::server::CreatureIdentifier>(Arena*);
template<> ::server::CreatureName* Arena::CreateMaybeMessage<::server::CreatureName>(Arena*);
template<> ::server::Creature_Motor* Arena::CreateMaybeMessage<::server::Creature_Motor>(Arena*);
template<> ::server::DatabaseInfo* Arena::CreateMaybeMessage<::server::DatabaseInfo>(Arena*);
template<> ::server::Frame* Arena::CreateMaybeMessage<::server::Frame>(Arena*);
template<> ::server::FrameResponse* Arena::CreateMaybeMessage<::server::FrameResponse>(Arena*);
template<> ::server::GetAllCreaturesResponse* Arena::CreateMaybeMessage<::server::GetAllCreaturesResponse>(Arena*);
template<> ::server::ListAnimationsResponse* Arena::CreateMaybeMessage<::server::ListAnimationsResponse>(Arena*);
template<> ::server::ListCreaturesResponse* Arena::CreateMaybeMessage<::server::ListCreaturesResponse>(Arena*);
template<> ::server::LogFilter* Arena::CreateMaybeMessage<::server::LogFilter>(Arena*);
template<> ::server::LogItem* Arena::CreateMaybeMessage<::server::LogItem>(Arena*);
template<> ::server::PlayAnimationRequest* Arena::CreateMaybeMessage<::server::PlayAnimationRequest>(Arena*);
template<> ::server::PlayAnimationResponse* Arena::CreateMaybeMessage<::server::PlayAnimationResponse>(Arena*);
template<> ::server::ServerStatus* Arena::CreateMaybeMessage<::server::ServerStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace server {

enum Creature_MotorType : int {
  Creature_MotorType_servo = 0,
  Creature_MotorType_stepper = 1,
  Creature_MotorType_Creature_MotorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Creature_MotorType_Creature_MotorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Creature_MotorType_IsValid(int value);
constexpr Creature_MotorType Creature_MotorType_MotorType_MIN = Creature_MotorType_servo;
constexpr Creature_MotorType Creature_MotorType_MotorType_MAX = Creature_MotorType_stepper;
constexpr int Creature_MotorType_MotorType_ARRAYSIZE = Creature_MotorType_MotorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Creature_MotorType_descriptor();
template<typename T>
inline const std::string& Creature_MotorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Creature_MotorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Creature_MotorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Creature_MotorType_descriptor(), enum_t_value);
}
inline bool Creature_MotorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Creature_MotorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Creature_MotorType>(
    Creature_MotorType_descriptor(), name, value);
}
enum LogLevel : int {
  trace = 0,
  debug = 1,
  info = 2,
  warn = 3,
  error = 4,
  critical = 5,
  off = 6,
  unknown = 7,
  LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LogLevel_IsValid(int value);
constexpr LogLevel LogLevel_MIN = trace;
constexpr LogLevel LogLevel_MAX = unknown;
constexpr int LogLevel_ARRAYSIZE = LogLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogLevel_descriptor();
template<typename T>
inline const std::string& LogLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogLevel_descriptor(), enum_t_value);
}
inline bool LogLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogLevel>(
    LogLevel_descriptor(), name, value);
}
enum SortBy : int {
  name = 0,
  number = 1,
  SortBy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SortBy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SortBy_IsValid(int value);
constexpr SortBy SortBy_MIN = name;
constexpr SortBy SortBy_MAX = number;
constexpr int SortBy_ARRAYSIZE = SortBy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SortBy_descriptor();
template<typename T>
inline const std::string& SortBy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SortBy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SortBy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SortBy_descriptor(), enum_t_value);
}
inline bool SortBy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SortBy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SortBy>(
    SortBy_descriptor(), name, value);
}
enum CreatureType : int {
  parrot = 0,
  wled_light = 1,
  other = 999,
  CreatureType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CreatureType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CreatureType_IsValid(int value);
constexpr CreatureType CreatureType_MIN = parrot;
constexpr CreatureType CreatureType_MAX = other;
constexpr int CreatureType_ARRAYSIZE = CreatureType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CreatureType_descriptor();
template<typename T>
inline const std::string& CreatureType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CreatureType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CreatureType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CreatureType_descriptor(), enum_t_value);
}
inline bool CreatureType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CreatureType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CreatureType>(
    CreatureType_descriptor(), name, value);
}
// ===================================================================

class CreatureIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.CreatureIdentifier) */ {
 public:
  inline CreatureIdentifier() : CreatureIdentifier(nullptr) {}
  ~CreatureIdentifier() override;
  explicit PROTOBUF_CONSTEXPR CreatureIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatureIdentifier(const CreatureIdentifier& from);
  CreatureIdentifier(CreatureIdentifier&& from) noexcept
    : CreatureIdentifier() {
    *this = ::std::move(from);
  }

  inline CreatureIdentifier& operator=(const CreatureIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatureIdentifier& operator=(CreatureIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatureIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatureIdentifier* internal_default_instance() {
    return reinterpret_cast<const CreatureIdentifier*>(
               &_CreatureIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreatureIdentifier& a, CreatureIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatureIdentifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatureIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatureIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatureIdentifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatureIdentifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreatureIdentifier& from) {
    CreatureIdentifier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatureIdentifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.CreatureIdentifier";
  }
  protected:
  explicit CreatureIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // bytes _id = 1;
  void clear__id();
  const std::string& _id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__id(ArgT0&& arg0, ArgT... args);
  std::string* mutable__id();
  PROTOBUF_NODISCARD std::string* release__id();
  void set_allocated__id(std::string* _id);
  private:
  const std::string& _internal__id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__id(const std::string& value);
  std::string* _internal_mutable__id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:server.CreatureIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class ListCreaturesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.ListCreaturesResponse) */ {
 public:
  inline ListCreaturesResponse() : ListCreaturesResponse(nullptr) {}
  ~ListCreaturesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListCreaturesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListCreaturesResponse(const ListCreaturesResponse& from);
  ListCreaturesResponse(ListCreaturesResponse&& from) noexcept
    : ListCreaturesResponse() {
    *this = ::std::move(from);
  }

  inline ListCreaturesResponse& operator=(const ListCreaturesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListCreaturesResponse& operator=(ListCreaturesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListCreaturesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListCreaturesResponse* internal_default_instance() {
    return reinterpret_cast<const ListCreaturesResponse*>(
               &_ListCreaturesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListCreaturesResponse& a, ListCreaturesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListCreaturesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListCreaturesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListCreaturesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListCreaturesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListCreaturesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListCreaturesResponse& from) {
    ListCreaturesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListCreaturesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.ListCreaturesResponse";
  }
  protected:
  explicit ListCreaturesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreaturesIdsFieldNumber = 1,
  };
  // repeated .server.CreatureIdentifier creaturesIds = 1;
  int creaturesids_size() const;
  private:
  int _internal_creaturesids_size() const;
  public:
  void clear_creaturesids();
  ::server::CreatureIdentifier* mutable_creaturesids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::CreatureIdentifier >*
      mutable_creaturesids();
  private:
  const ::server::CreatureIdentifier& _internal_creaturesids(int index) const;
  ::server::CreatureIdentifier* _internal_add_creaturesids();
  public:
  const ::server::CreatureIdentifier& creaturesids(int index) const;
  ::server::CreatureIdentifier* add_creaturesids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::CreatureIdentifier >&
      creaturesids() const;

  // @@protoc_insertion_point(class_scope:server.ListCreaturesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::CreatureIdentifier > creaturesids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class GetAllCreaturesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.GetAllCreaturesResponse) */ {
 public:
  inline GetAllCreaturesResponse() : GetAllCreaturesResponse(nullptr) {}
  ~GetAllCreaturesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetAllCreaturesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAllCreaturesResponse(const GetAllCreaturesResponse& from);
  GetAllCreaturesResponse(GetAllCreaturesResponse&& from) noexcept
    : GetAllCreaturesResponse() {
    *this = ::std::move(from);
  }

  inline GetAllCreaturesResponse& operator=(const GetAllCreaturesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllCreaturesResponse& operator=(GetAllCreaturesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAllCreaturesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAllCreaturesResponse* internal_default_instance() {
    return reinterpret_cast<const GetAllCreaturesResponse*>(
               &_GetAllCreaturesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetAllCreaturesResponse& a, GetAllCreaturesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAllCreaturesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAllCreaturesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAllCreaturesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAllCreaturesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAllCreaturesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAllCreaturesResponse& from) {
    GetAllCreaturesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllCreaturesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.GetAllCreaturesResponse";
  }
  protected:
  explicit GetAllCreaturesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreaturesFieldNumber = 1,
  };
  // repeated .server.Creature creatures = 1;
  int creatures_size() const;
  private:
  int _internal_creatures_size() const;
  public:
  void clear_creatures();
  ::server::Creature* mutable_creatures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature >*
      mutable_creatures();
  private:
  const ::server::Creature& _internal_creatures(int index) const;
  ::server::Creature* _internal_add_creatures();
  public:
  const ::server::Creature& creatures(int index) const;
  ::server::Creature* add_creatures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature >&
      creatures() const;

  // @@protoc_insertion_point(class_scope:server.GetAllCreaturesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature > creatures_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class CreatureFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.CreatureFilter) */ {
 public:
  inline CreatureFilter() : CreatureFilter(nullptr) {}
  ~CreatureFilter() override;
  explicit PROTOBUF_CONSTEXPR CreatureFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatureFilter(const CreatureFilter& from);
  CreatureFilter(CreatureFilter&& from) noexcept
    : CreatureFilter() {
    *this = ::std::move(from);
  }

  inline CreatureFilter& operator=(const CreatureFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatureFilter& operator=(CreatureFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatureFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatureFilter* internal_default_instance() {
    return reinterpret_cast<const CreatureFilter*>(
               &_CreatureFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreatureFilter& a, CreatureFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatureFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatureFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatureFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatureFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatureFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreatureFilter& from) {
    CreatureFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatureFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.CreatureFilter";
  }
  protected:
  explicit CreatureFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
    kSortByFieldNumber = 2,
  };
  // string filter = 1;
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // .server.SortBy sortBy = 2;
  void clear_sortby();
  ::server::SortBy sortby() const;
  void set_sortby(::server::SortBy value);
  private:
  ::server::SortBy _internal_sortby() const;
  void _internal_set_sortby(::server::SortBy value);
  public:

  // @@protoc_insertion_point(class_scope:server.CreatureFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    int sortby_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class DatabaseInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.DatabaseInfo) */ {
 public:
  inline DatabaseInfo() : DatabaseInfo(nullptr) {}
  ~DatabaseInfo() override;
  explicit PROTOBUF_CONSTEXPR DatabaseInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatabaseInfo(const DatabaseInfo& from);
  DatabaseInfo(DatabaseInfo&& from) noexcept
    : DatabaseInfo() {
    *this = ::std::move(from);
  }

  inline DatabaseInfo& operator=(const DatabaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatabaseInfo& operator=(DatabaseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatabaseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatabaseInfo* internal_default_instance() {
    return reinterpret_cast<const DatabaseInfo*>(
               &_DatabaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DatabaseInfo& a, DatabaseInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DatabaseInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatabaseInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatabaseInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatabaseInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatabaseInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatabaseInfo& from) {
    DatabaseInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatabaseInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.DatabaseInfo";
  }
  protected:
  explicit DatabaseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kHelpFieldNumber = 2,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string help = 2;
  void clear_help();
  const std::string& help() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_help(ArgT0&& arg0, ArgT... args);
  std::string* mutable_help();
  PROTOBUF_NODISCARD std::string* release_help();
  void set_allocated_help(std::string* help);
  private:
  const std::string& _internal_help() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_help(const std::string& value);
  std::string* _internal_mutable_help();
  public:

  // @@protoc_insertion_point(class_scope:server.DatabaseInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr help_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class LogFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.LogFilter) */ {
 public:
  inline LogFilter() : LogFilter(nullptr) {}
  ~LogFilter() override;
  explicit PROTOBUF_CONSTEXPR LogFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogFilter(const LogFilter& from);
  LogFilter(LogFilter&& from) noexcept
    : LogFilter() {
    *this = ::std::move(from);
  }

  inline LogFilter& operator=(const LogFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogFilter& operator=(LogFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogFilter* internal_default_instance() {
    return reinterpret_cast<const LogFilter*>(
               &_LogFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LogFilter& a, LogFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(LogFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogFilter& from) {
    LogFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.LogFilter";
  }
  protected:
  explicit LogFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
  };
  // .server.LogLevel level = 1;
  void clear_level();
  ::server::LogLevel level() const;
  void set_level(::server::LogLevel value);
  private:
  ::server::LogLevel _internal_level() const;
  void _internal_set_level(::server::LogLevel value);
  public:

  // @@protoc_insertion_point(class_scope:server.LogFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class CreatureId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.CreatureId) */ {
 public:
  inline CreatureId() : CreatureId(nullptr) {}
  ~CreatureId() override;
  explicit PROTOBUF_CONSTEXPR CreatureId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatureId(const CreatureId& from);
  CreatureId(CreatureId&& from) noexcept
    : CreatureId() {
    *this = ::std::move(from);
  }

  inline CreatureId& operator=(const CreatureId& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatureId& operator=(CreatureId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatureId& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatureId* internal_default_instance() {
    return reinterpret_cast<const CreatureId*>(
               &_CreatureId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CreatureId& a, CreatureId& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatureId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatureId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatureId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatureId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatureId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreatureId& from) {
    CreatureId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatureId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.CreatureId";
  }
  protected:
  explicit CreatureId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes _id = 1;
  void clear__id();
  const std::string& _id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__id(ArgT0&& arg0, ArgT... args);
  std::string* mutable__id();
  PROTOBUF_NODISCARD std::string* release__id();
  void set_allocated__id(std::string* _id);
  private:
  const std::string& _internal__id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__id(const std::string& value);
  std::string* _internal_mutable__id();
  public:

  // @@protoc_insertion_point(class_scope:server.CreatureId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class CreatureName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.CreatureName) */ {
 public:
  inline CreatureName() : CreatureName(nullptr) {}
  ~CreatureName() override;
  explicit PROTOBUF_CONSTEXPR CreatureName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatureName(const CreatureName& from);
  CreatureName(CreatureName&& from) noexcept
    : CreatureName() {
    *this = ::std::move(from);
  }

  inline CreatureName& operator=(const CreatureName& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatureName& operator=(CreatureName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatureName& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatureName* internal_default_instance() {
    return reinterpret_cast<const CreatureName*>(
               &_CreatureName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreatureName& a, CreatureName& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatureName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatureName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatureName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatureName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatureName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreatureName& from) {
    CreatureName::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatureName* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.CreatureName";
  }
  protected:
  explicit CreatureName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:server.CreatureName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class Creature_Motor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.Creature.Motor) */ {
 public:
  inline Creature_Motor() : Creature_Motor(nullptr) {}
  ~Creature_Motor() override;
  explicit PROTOBUF_CONSTEXPR Creature_Motor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Creature_Motor(const Creature_Motor& from);
  Creature_Motor(Creature_Motor&& from) noexcept
    : Creature_Motor() {
    *this = ::std::move(from);
  }

  inline Creature_Motor& operator=(const Creature_Motor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Creature_Motor& operator=(Creature_Motor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Creature_Motor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Creature_Motor* internal_default_instance() {
    return reinterpret_cast<const Creature_Motor*>(
               &_Creature_Motor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Creature_Motor& a, Creature_Motor& b) {
    a.Swap(&b);
  }
  inline void Swap(Creature_Motor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Creature_Motor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Creature_Motor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Creature_Motor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Creature_Motor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Creature_Motor& from) {
    Creature_Motor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Creature_Motor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.Creature.Motor";
  }
  protected:
  explicit Creature_Motor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
    kNumberFieldNumber = 4,
    kMaxValueFieldNumber = 5,
    kMinValueFieldNumber = 6,
    kSmoothingValueFieldNumber = 7,
  };
  // bytes _id = 1;
  void clear__id();
  const std::string& _id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__id(ArgT0&& arg0, ArgT... args);
  std::string* mutable__id();
  PROTOBUF_NODISCARD std::string* release__id();
  void set_allocated__id(std::string* _id);
  private:
  const std::string& _internal__id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__id(const std::string& value);
  std::string* _internal_mutable__id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .server.Creature.MotorType type = 3;
  void clear_type();
  ::server::Creature_MotorType type() const;
  void set_type(::server::Creature_MotorType value);
  private:
  ::server::Creature_MotorType _internal_type() const;
  void _internal_set_type(::server::Creature_MotorType value);
  public:

  // uint32 number = 4;
  void clear_number();
  uint32_t number() const;
  void set_number(uint32_t value);
  private:
  uint32_t _internal_number() const;
  void _internal_set_number(uint32_t value);
  public:

  // uint32 max_value = 5;
  void clear_max_value();
  uint32_t max_value() const;
  void set_max_value(uint32_t value);
  private:
  uint32_t _internal_max_value() const;
  void _internal_set_max_value(uint32_t value);
  public:

  // uint32 min_value = 6;
  void clear_min_value();
  uint32_t min_value() const;
  void set_min_value(uint32_t value);
  private:
  uint32_t _internal_min_value() const;
  void _internal_set_min_value(uint32_t value);
  public:

  // double smoothing_value = 7;
  void clear_smoothing_value();
  double smoothing_value() const;
  void set_smoothing_value(double value);
  private:
  double _internal_smoothing_value() const;
  void _internal_set_smoothing_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:server.Creature.Motor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int type_;
    uint32_t number_;
    uint32_t max_value_;
    uint32_t min_value_;
    double smoothing_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class Creature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.Creature) */ {
 public:
  inline Creature() : Creature(nullptr) {}
  ~Creature() override;
  explicit PROTOBUF_CONSTEXPR Creature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Creature(const Creature& from);
  Creature(Creature&& from) noexcept
    : Creature() {
    *this = ::std::move(from);
  }

  inline Creature& operator=(const Creature& from) {
    CopyFrom(from);
    return *this;
  }
  inline Creature& operator=(Creature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Creature& default_instance() {
    return *internal_default_instance();
  }
  static inline const Creature* internal_default_instance() {
    return reinterpret_cast<const Creature*>(
               &_Creature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Creature& a, Creature& b) {
    a.Swap(&b);
  }
  inline void Swap(Creature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Creature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Creature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Creature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Creature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Creature& from) {
    Creature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Creature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.Creature";
  }
  protected:
  explicit Creature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Creature_Motor Motor;

  typedef Creature_MotorType MotorType;
  static constexpr MotorType servo =
    Creature_MotorType_servo;
  static constexpr MotorType stepper =
    Creature_MotorType_stepper;
  static inline bool MotorType_IsValid(int value) {
    return Creature_MotorType_IsValid(value);
  }
  static constexpr MotorType MotorType_MIN =
    Creature_MotorType_MotorType_MIN;
  static constexpr MotorType MotorType_MAX =
    Creature_MotorType_MotorType_MAX;
  static constexpr int MotorType_ARRAYSIZE =
    Creature_MotorType_MotorType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MotorType_descriptor() {
    return Creature_MotorType_descriptor();
  }
  template<typename T>
  static inline const std::string& MotorType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MotorType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MotorType_Name.");
    return Creature_MotorType_Name(enum_t_value);
  }
  static inline bool MotorType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MotorType* value) {
    return Creature_MotorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMotorsFieldNumber = 90,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kSacnIpFieldNumber = 4,
    kLastUpdatedFieldNumber = 3,
    kUniverseFieldNumber = 5,
    kDmxBaseFieldNumber = 6,
    kNumberOfMotorsFieldNumber = 7,
    kTypeFieldNumber = 8,
  };
  // repeated .server.Creature.Motor motors = 90;
  int motors_size() const;
  private:
  int _internal_motors_size() const;
  public:
  void clear_motors();
  ::server::Creature_Motor* mutable_motors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor >*
      mutable_motors();
  private:
  const ::server::Creature_Motor& _internal_motors(int index) const;
  ::server::Creature_Motor* _internal_add_motors();
  public:
  const ::server::Creature_Motor& motors(int index) const;
  ::server::Creature_Motor* add_motors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor >&
      motors() const;

  // bytes _id = 1;
  void clear__id();
  const std::string& _id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__id(ArgT0&& arg0, ArgT... args);
  std::string* mutable__id();
  PROTOBUF_NODISCARD std::string* release__id();
  void set_allocated__id(std::string* _id);
  private:
  const std::string& _internal__id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__id(const std::string& value);
  std::string* _internal_mutable__id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string sacn_ip = 4;
  void clear_sacn_ip();
  const std::string& sacn_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sacn_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sacn_ip();
  PROTOBUF_NODISCARD std::string* release_sacn_ip();
  void set_allocated_sacn_ip(std::string* sacn_ip);
  private:
  const std::string& _internal_sacn_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sacn_ip(const std::string& value);
  std::string* _internal_mutable_sacn_ip();
  public:

  // .google.protobuf.Timestamp last_updated = 3;
  bool has_last_updated() const;
  private:
  bool _internal_has_last_updated() const;
  public:
  void clear_last_updated();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_updated() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_updated();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_updated();
  void set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_updated() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_updated();
  public:
  void unsafe_arena_set_allocated_last_updated(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_updated();

  // uint32 universe = 5;
  void clear_universe();
  uint32_t universe() const;
  void set_universe(uint32_t value);
  private:
  uint32_t _internal_universe() const;
  void _internal_set_universe(uint32_t value);
  public:

  // uint32 dmx_base = 6;
  void clear_dmx_base();
  uint32_t dmx_base() const;
  void set_dmx_base(uint32_t value);
  private:
  uint32_t _internal_dmx_base() const;
  void _internal_set_dmx_base(uint32_t value);
  public:

  // uint32 number_of_motors = 7;
  void clear_number_of_motors();
  uint32_t number_of_motors() const;
  void set_number_of_motors(uint32_t value);
  private:
  uint32_t _internal_number_of_motors() const;
  void _internal_set_number_of_motors(uint32_t value);
  public:

  // .server.CreatureType type = 8;
  void clear_type();
  ::server::CreatureType type() const;
  void set_type(::server::CreatureType value);
  private:
  ::server::CreatureType _internal_type() const;
  void _internal_set_type(::server::CreatureType value);
  public:

  // @@protoc_insertion_point(class_scope:server.Creature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor > motors_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sacn_ip_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated_;
    uint32_t universe_;
    uint32_t dmx_base_;
    uint32_t number_of_motors_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class LogItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.LogItem) */ {
 public:
  inline LogItem() : LogItem(nullptr) {}
  ~LogItem() override;
  explicit PROTOBUF_CONSTEXPR LogItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogItem(const LogItem& from);
  LogItem(LogItem&& from) noexcept
    : LogItem() {
    *this = ::std::move(from);
  }

  inline LogItem& operator=(const LogItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogItem& operator=(LogItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogItem* internal_default_instance() {
    return reinterpret_cast<const LogItem*>(
               &_LogItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LogItem& a, LogItem& b) {
    a.Swap(&b);
  }
  inline void Swap(LogItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogItem& from) {
    LogItem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.LogItem";
  }
  protected:
  explicit LogItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kLoggerNameFieldNumber = 4,
    kTimestampFieldNumber = 2,
    kLevelFieldNumber = 1,
    kThreadIdFieldNumber = 5,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string logger_name = 4;
  void clear_logger_name();
  const std::string& logger_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logger_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logger_name();
  PROTOBUF_NODISCARD std::string* release_logger_name();
  void set_allocated_logger_name(std::string* logger_name);
  private:
  const std::string& _internal_logger_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logger_name(const std::string& value);
  std::string* _internal_mutable_logger_name();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .server.LogLevel level = 1;
  void clear_level();
  ::server::LogLevel level() const;
  void set_level(::server::LogLevel value);
  private:
  ::server::LogLevel _internal_level() const;
  void _internal_set_level(::server::LogLevel value);
  public:

  // uint32 thread_id = 5;
  void clear_thread_id();
  uint32_t thread_id() const;
  void set_thread_id(uint32_t value);
  private:
  uint32_t _internal_thread_id() const;
  void _internal_set_thread_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:server.LogItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logger_name_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    int level_;
    uint32_t thread_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class Frame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.Frame) */ {
 public:
  inline Frame() : Frame(nullptr) {}
  ~Frame() override;
  explicit PROTOBUF_CONSTEXPR Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Frame(const Frame& from);
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Frame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Frame& from) {
    Frame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.Frame";
  }
  protected:
  explicit Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatureNameFieldNumber = 3,
    kSacnIpFieldNumber = 4,
    kFrameFieldNumber = 10,
    kUniverseFieldNumber = 1,
    kDmxOffsetFieldNumber = 2,
    kNumberOfMotorsFieldNumber = 5,
  };
  // string creature_name = 3;
  void clear_creature_name();
  const std::string& creature_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creature_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creature_name();
  PROTOBUF_NODISCARD std::string* release_creature_name();
  void set_allocated_creature_name(std::string* creature_name);
  private:
  const std::string& _internal_creature_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creature_name(const std::string& value);
  std::string* _internal_mutable_creature_name();
  public:

  // string sacn_ip = 4;
  void clear_sacn_ip();
  const std::string& sacn_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sacn_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sacn_ip();
  PROTOBUF_NODISCARD std::string* release_sacn_ip();
  void set_allocated_sacn_ip(std::string* sacn_ip);
  private:
  const std::string& _internal_sacn_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sacn_ip(const std::string& value);
  std::string* _internal_mutable_sacn_ip();
  public:

  // bytes frame = 10;
  void clear_frame();
  const std::string& frame() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame();
  PROTOBUF_NODISCARD std::string* release_frame();
  void set_allocated_frame(std::string* frame);
  private:
  const std::string& _internal_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame(const std::string& value);
  std::string* _internal_mutable_frame();
  public:

  // uint32 universe = 1;
  void clear_universe();
  uint32_t universe() const;
  void set_universe(uint32_t value);
  private:
  uint32_t _internal_universe() const;
  void _internal_set_universe(uint32_t value);
  public:

  // uint32 dmx_offset = 2;
  void clear_dmx_offset();
  uint32_t dmx_offset() const;
  void set_dmx_offset(uint32_t value);
  private:
  uint32_t _internal_dmx_offset() const;
  void _internal_set_dmx_offset(uint32_t value);
  public:

  // uint32 number_of_motors = 5;
  void clear_number_of_motors();
  uint32_t number_of_motors() const;
  void set_number_of_motors(uint32_t value);
  private:
  uint32_t _internal_number_of_motors() const;
  void _internal_set_number_of_motors(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:server.Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creature_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sacn_ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_;
    uint32_t universe_;
    uint32_t dmx_offset_;
    uint32_t number_of_motors_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class FrameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.FrameResponse) */ {
 public:
  inline FrameResponse() : FrameResponse(nullptr) {}
  ~FrameResponse() override;
  explicit PROTOBUF_CONSTEXPR FrameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameResponse(const FrameResponse& from);
  FrameResponse(FrameResponse&& from) noexcept
    : FrameResponse() {
    *this = ::std::move(from);
  }

  inline FrameResponse& operator=(const FrameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameResponse& operator=(FrameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameResponse* internal_default_instance() {
    return reinterpret_cast<const FrameResponse*>(
               &_FrameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FrameResponse& a, FrameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrameResponse& from) {
    FrameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.FrameResponse";
  }
  protected:
  explicit FrameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kFramesProcessedFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint32 frames_processed = 1;
  void clear_frames_processed();
  uint32_t frames_processed() const;
  void set_frames_processed(uint32_t value);
  private:
  uint32_t _internal_frames_processed() const;
  void _internal_set_frames_processed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:server.FrameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint32_t frames_processed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class ServerStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.ServerStatus) */ {
 public:
  inline ServerStatus() : ServerStatus(nullptr) {}
  ~ServerStatus() override;
  explicit PROTOBUF_CONSTEXPR ServerStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerStatus(const ServerStatus& from);
  ServerStatus(ServerStatus&& from) noexcept
    : ServerStatus() {
    *this = ::std::move(from);
  }

  inline ServerStatus& operator=(const ServerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerStatus& operator=(ServerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerStatus* internal_default_instance() {
    return reinterpret_cast<const ServerStatus*>(
               &_ServerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ServerStatus& a, ServerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerStatus& from) {
    ServerStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.ServerStatus";
  }
  protected:
  explicit ServerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartedAtFieldNumber = 2,
    kFramesProcessedFieldNumber = 1,
  };
  // .google.protobuf.Timestamp started_at = 2;
  bool has_started_at() const;
  private:
  bool _internal_has_started_at() const;
  public:
  void clear_started_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& started_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_started_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_started_at();
  void set_allocated_started_at(::PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_started_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_started_at();
  public:
  void unsafe_arena_set_allocated_started_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_started_at();

  // uint64 frames_processed = 1;
  void clear_frames_processed();
  uint64_t frames_processed() const;
  void set_frames_processed(uint64_t value);
  private:
  uint64_t _internal_frames_processed() const;
  void _internal_set_frames_processed(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:server.ServerStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at_;
    uint64_t frames_processed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class Animation_Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.Animation.Metadata) */ {
 public:
  inline Animation_Metadata() : Animation_Metadata(nullptr) {}
  ~Animation_Metadata() override;
  explicit PROTOBUF_CONSTEXPR Animation_Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Animation_Metadata(const Animation_Metadata& from);
  Animation_Metadata(Animation_Metadata&& from) noexcept
    : Animation_Metadata() {
    *this = ::std::move(from);
  }

  inline Animation_Metadata& operator=(const Animation_Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Animation_Metadata& operator=(Animation_Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Animation_Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Animation_Metadata* internal_default_instance() {
    return reinterpret_cast<const Animation_Metadata*>(
               &_Animation_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Animation_Metadata& a, Animation_Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Animation_Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Animation_Metadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Animation_Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Animation_Metadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Animation_Metadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Animation_Metadata& from) {
    Animation_Metadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Animation_Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.Animation.Metadata";
  }
  protected:
  explicit Animation_Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
    kNotesFieldNumber = 6,
    kMillisecondsPerFrameFieldNumber = 2,
    kNumberOfFramesFieldNumber = 3,
    kCreatureTypeFieldNumber = 4,
    kNumberOfMotorsFieldNumber = 5,
  };
  // string title = 1;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string notes = 6;
  void clear_notes();
  const std::string& notes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notes();
  PROTOBUF_NODISCARD std::string* release_notes();
  void set_allocated_notes(std::string* notes);
  private:
  const std::string& _internal_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notes(const std::string& value);
  std::string* _internal_mutable_notes();
  public:

  // int32 milliseconds_per_frame = 2;
  void clear_milliseconds_per_frame();
  int32_t milliseconds_per_frame() const;
  void set_milliseconds_per_frame(int32_t value);
  private:
  int32_t _internal_milliseconds_per_frame() const;
  void _internal_set_milliseconds_per_frame(int32_t value);
  public:

  // int32 number_of_frames = 3;
  void clear_number_of_frames();
  int32_t number_of_frames() const;
  void set_number_of_frames(int32_t value);
  private:
  int32_t _internal_number_of_frames() const;
  void _internal_set_number_of_frames(int32_t value);
  public:

  // .server.CreatureType creature_type = 4;
  void clear_creature_type();
  ::server::CreatureType creature_type() const;
  void set_creature_type(::server::CreatureType value);
  private:
  ::server::CreatureType _internal_creature_type() const;
  void _internal_set_creature_type(::server::CreatureType value);
  public:

  // int32 number_of_motors = 5;
  void clear_number_of_motors();
  int32_t number_of_motors() const;
  void set_number_of_motors(int32_t value);
  private:
  int32_t _internal_number_of_motors() const;
  void _internal_set_number_of_motors(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:server.Animation.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notes_;
    int32_t milliseconds_per_frame_;
    int32_t number_of_frames_;
    int creature_type_;
    int32_t number_of_motors_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class Animation_Frame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.Animation.Frame) */ {
 public:
  inline Animation_Frame() : Animation_Frame(nullptr) {}
  ~Animation_Frame() override;
  explicit PROTOBUF_CONSTEXPR Animation_Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Animation_Frame(const Animation_Frame& from);
  Animation_Frame(Animation_Frame&& from) noexcept
    : Animation_Frame() {
    *this = ::std::move(from);
  }

  inline Animation_Frame& operator=(const Animation_Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Animation_Frame& operator=(Animation_Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Animation_Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Animation_Frame* internal_default_instance() {
    return reinterpret_cast<const Animation_Frame*>(
               &_Animation_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Animation_Frame& a, Animation_Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Animation_Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Animation_Frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Animation_Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Animation_Frame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Animation_Frame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Animation_Frame& from) {
    Animation_Frame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Animation_Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.Animation.Frame";
  }
  protected:
  explicit Animation_Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBytesFieldNumber = 1,
  };
  // repeated bytes bytes = 1;
  int bytes_size() const;
  private:
  int _internal_bytes_size() const;
  public:
  void clear_bytes();
  const std::string& bytes(int index) const;
  std::string* mutable_bytes(int index);
  void set_bytes(int index, const std::string& value);
  void set_bytes(int index, std::string&& value);
  void set_bytes(int index, const char* value);
  void set_bytes(int index, const void* value, size_t size);
  std::string* add_bytes();
  void add_bytes(const std::string& value);
  void add_bytes(std::string&& value);
  void add_bytes(const char* value);
  void add_bytes(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& bytes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_bytes();
  private:
  const std::string& _internal_bytes(int index) const;
  std::string* _internal_add_bytes();
  public:

  // @@protoc_insertion_point(class_scope:server.Animation.Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> bytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class Animation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.Animation) */ {
 public:
  inline Animation() : Animation(nullptr) {}
  ~Animation() override;
  explicit PROTOBUF_CONSTEXPR Animation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Animation(const Animation& from);
  Animation(Animation&& from) noexcept
    : Animation() {
    *this = ::std::move(from);
  }

  inline Animation& operator=(const Animation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Animation& operator=(Animation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Animation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Animation* internal_default_instance() {
    return reinterpret_cast<const Animation*>(
               &_Animation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Animation& a, Animation& b) {
    a.Swap(&b);
  }
  inline void Swap(Animation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Animation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Animation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Animation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Animation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Animation& from) {
    Animation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Animation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.Animation";
  }
  protected:
  explicit Animation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Animation_Metadata Metadata;
  typedef Animation_Frame Frame;

  // accessors -------------------------------------------------------

  enum : int {
    kFramesFieldNumber = 3,
    kIdFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // repeated .server.Animation.Frame frames = 3;
  int frames_size() const;
  private:
  int _internal_frames_size() const;
  public:
  void clear_frames();
  ::server::Animation_Frame* mutable_frames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Animation_Frame >*
      mutable_frames();
  private:
  const ::server::Animation_Frame& _internal_frames(int index) const;
  ::server::Animation_Frame* _internal_add_frames();
  public:
  const ::server::Animation_Frame& frames(int index) const;
  ::server::Animation_Frame* add_frames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Animation_Frame >&
      frames() const;

  // bytes _id = 1;
  void clear__id();
  const std::string& _id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__id(ArgT0&& arg0, ArgT... args);
  std::string* mutable__id();
  PROTOBUF_NODISCARD std::string* release__id();
  void set_allocated__id(std::string* _id);
  private:
  const std::string& _internal__id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__id(const std::string& value);
  std::string* _internal_mutable__id();
  public:

  // .server.Animation.Metadata metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::server::Animation_Metadata& metadata() const;
  PROTOBUF_NODISCARD ::server::Animation_Metadata* release_metadata();
  ::server::Animation_Metadata* mutable_metadata();
  void set_allocated_metadata(::server::Animation_Metadata* metadata);
  private:
  const ::server::Animation_Metadata& _internal_metadata() const;
  ::server::Animation_Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::server::Animation_Metadata* metadata);
  ::server::Animation_Metadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:server.Animation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Animation_Frame > frames_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _id_;
    ::server::Animation_Metadata* metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AnimationId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.AnimationId) */ {
 public:
  inline AnimationId() : AnimationId(nullptr) {}
  ~AnimationId() override;
  explicit PROTOBUF_CONSTEXPR AnimationId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnimationId(const AnimationId& from);
  AnimationId(AnimationId&& from) noexcept
    : AnimationId() {
    *this = ::std::move(from);
  }

  inline AnimationId& operator=(const AnimationId& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimationId& operator=(AnimationId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnimationId& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnimationId* internal_default_instance() {
    return reinterpret_cast<const AnimationId*>(
               &_AnimationId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AnimationId& a, AnimationId& b) {
    a.Swap(&b);
  }
  inline void Swap(AnimationId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimationId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnimationId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnimationId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnimationId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnimationId& from) {
    AnimationId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnimationId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.AnimationId";
  }
  protected:
  explicit AnimationId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes _id = 1;
  void clear__id();
  const std::string& _id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__id(ArgT0&& arg0, ArgT... args);
  std::string* mutable__id();
  PROTOBUF_NODISCARD std::string* release__id();
  void set_allocated__id(std::string* _id);
  private:
  const std::string& _internal__id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__id(const std::string& value);
  std::string* _internal_mutable__id();
  public:

  // @@protoc_insertion_point(class_scope:server.AnimationId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AnimationFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.AnimationFilter) */ {
 public:
  inline AnimationFilter() : AnimationFilter(nullptr) {}
  ~AnimationFilter() override;
  explicit PROTOBUF_CONSTEXPR AnimationFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnimationFilter(const AnimationFilter& from);
  AnimationFilter(AnimationFilter&& from) noexcept
    : AnimationFilter() {
    *this = ::std::move(from);
  }

  inline AnimationFilter& operator=(const AnimationFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimationFilter& operator=(AnimationFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnimationFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnimationFilter* internal_default_instance() {
    return reinterpret_cast<const AnimationFilter*>(
               &_AnimationFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(AnimationFilter& a, AnimationFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(AnimationFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimationFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnimationFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnimationFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnimationFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnimationFilter& from) {
    AnimationFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnimationFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.AnimationFilter";
  }
  protected:
  explicit AnimationFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .server.CreatureType type = 1;
  void clear_type();
  ::server::CreatureType type() const;
  void set_type(::server::CreatureType value);
  private:
  ::server::CreatureType _internal_type() const;
  void _internal_set_type(::server::CreatureType value);
  public:

  // @@protoc_insertion_point(class_scope:server.AnimationFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class ListAnimationsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.ListAnimationsResponse) */ {
 public:
  inline ListAnimationsResponse() : ListAnimationsResponse(nullptr) {}
  ~ListAnimationsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListAnimationsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAnimationsResponse(const ListAnimationsResponse& from);
  ListAnimationsResponse(ListAnimationsResponse&& from) noexcept
    : ListAnimationsResponse() {
    *this = ::std::move(from);
  }

  inline ListAnimationsResponse& operator=(const ListAnimationsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAnimationsResponse& operator=(ListAnimationsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAnimationsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAnimationsResponse* internal_default_instance() {
    return reinterpret_cast<const ListAnimationsResponse*>(
               &_ListAnimationsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ListAnimationsResponse& a, ListAnimationsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAnimationsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAnimationsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAnimationsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAnimationsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAnimationsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListAnimationsResponse& from) {
    ListAnimationsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAnimationsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.ListAnimationsResponse";
  }
  protected:
  explicit ListAnimationsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnimationsFieldNumber = 1,
  };
  // repeated .server.AnimationIdentifier animations = 1;
  int animations_size() const;
  private:
  int _internal_animations_size() const;
  public:
  void clear_animations();
  ::server::AnimationIdentifier* mutable_animations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::AnimationIdentifier >*
      mutable_animations();
  private:
  const ::server::AnimationIdentifier& _internal_animations(int index) const;
  ::server::AnimationIdentifier* _internal_add_animations();
  public:
  const ::server::AnimationIdentifier& animations(int index) const;
  ::server::AnimationIdentifier* add_animations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::AnimationIdentifier >&
      animations() const;

  // @@protoc_insertion_point(class_scope:server.ListAnimationsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::AnimationIdentifier > animations_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class AnimationIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.AnimationIdentifier) */ {
 public:
  inline AnimationIdentifier() : AnimationIdentifier(nullptr) {}
  ~AnimationIdentifier() override;
  explicit PROTOBUF_CONSTEXPR AnimationIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AnimationIdentifier(const AnimationIdentifier& from);
  AnimationIdentifier(AnimationIdentifier&& from) noexcept
    : AnimationIdentifier() {
    *this = ::std::move(from);
  }

  inline AnimationIdentifier& operator=(const AnimationIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimationIdentifier& operator=(AnimationIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnimationIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnimationIdentifier* internal_default_instance() {
    return reinterpret_cast<const AnimationIdentifier*>(
               &_AnimationIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AnimationIdentifier& a, AnimationIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(AnimationIdentifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimationIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnimationIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AnimationIdentifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AnimationIdentifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AnimationIdentifier& from) {
    AnimationIdentifier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnimationIdentifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.AnimationIdentifier";
  }
  protected:
  explicit AnimationIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // bytes _id = 1;
  void clear__id();
  const std::string& _id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__id(ArgT0&& arg0, ArgT... args);
  std::string* mutable__id();
  PROTOBUF_NODISCARD std::string* release__id();
  void set_allocated__id(std::string* _id);
  private:
  const std::string& _internal__id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__id(const std::string& value);
  std::string* _internal_mutable__id();
  public:

  // .server.Animation.Metadata metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::server::Animation_Metadata& metadata() const;
  PROTOBUF_NODISCARD ::server::Animation_Metadata* release_metadata();
  ::server::Animation_Metadata* mutable_metadata();
  void set_allocated_metadata(::server::Animation_Metadata* metadata);
  private:
  const ::server::Animation_Metadata& _internal_metadata() const;
  ::server::Animation_Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::server::Animation_Metadata* metadata);
  ::server::Animation_Metadata* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:server.AnimationIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _id_;
    ::server::Animation_Metadata* metadata_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class PlayAnimationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.PlayAnimationRequest) */ {
 public:
  inline PlayAnimationRequest() : PlayAnimationRequest(nullptr) {}
  ~PlayAnimationRequest() override;
  explicit PROTOBUF_CONSTEXPR PlayAnimationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayAnimationRequest(const PlayAnimationRequest& from);
  PlayAnimationRequest(PlayAnimationRequest&& from) noexcept
    : PlayAnimationRequest() {
    *this = ::std::move(from);
  }

  inline PlayAnimationRequest& operator=(const PlayAnimationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayAnimationRequest& operator=(PlayAnimationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayAnimationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayAnimationRequest* internal_default_instance() {
    return reinterpret_cast<const PlayAnimationRequest*>(
               &_PlayAnimationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PlayAnimationRequest& a, PlayAnimationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayAnimationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayAnimationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayAnimationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayAnimationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayAnimationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayAnimationRequest& from) {
    PlayAnimationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayAnimationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.PlayAnimationRequest";
  }
  protected:
  explicit PlayAnimationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatureIdFieldNumber = 1,
    kAnimationIdFieldNumber = 2,
  };
  // .server.CreatureId creatureId = 1;
  bool has_creatureid() const;
  private:
  bool _internal_has_creatureid() const;
  public:
  void clear_creatureid();
  const ::server::CreatureId& creatureid() const;
  PROTOBUF_NODISCARD ::server::CreatureId* release_creatureid();
  ::server::CreatureId* mutable_creatureid();
  void set_allocated_creatureid(::server::CreatureId* creatureid);
  private:
  const ::server::CreatureId& _internal_creatureid() const;
  ::server::CreatureId* _internal_mutable_creatureid();
  public:
  void unsafe_arena_set_allocated_creatureid(
      ::server::CreatureId* creatureid);
  ::server::CreatureId* unsafe_arena_release_creatureid();

  // .server.AnimationId animationId = 2;
  bool has_animationid() const;
  private:
  bool _internal_has_animationid() const;
  public:
  void clear_animationid();
  const ::server::AnimationId& animationid() const;
  PROTOBUF_NODISCARD ::server::AnimationId* release_animationid();
  ::server::AnimationId* mutable_animationid();
  void set_allocated_animationid(::server::AnimationId* animationid);
  private:
  const ::server::AnimationId& _internal_animationid() const;
  ::server::AnimationId* _internal_mutable_animationid();
  public:
  void unsafe_arena_set_allocated_animationid(
      ::server::AnimationId* animationid);
  ::server::AnimationId* unsafe_arena_release_animationid();

  // @@protoc_insertion_point(class_scope:server.PlayAnimationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::server::CreatureId* creatureid_;
    ::server::AnimationId* animationid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class PlayAnimationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.PlayAnimationResponse) */ {
 public:
  inline PlayAnimationResponse() : PlayAnimationResponse(nullptr) {}
  ~PlayAnimationResponse() override;
  explicit PROTOBUF_CONSTEXPR PlayAnimationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayAnimationResponse(const PlayAnimationResponse& from);
  PlayAnimationResponse(PlayAnimationResponse&& from) noexcept
    : PlayAnimationResponse() {
    *this = ::std::move(from);
  }

  inline PlayAnimationResponse& operator=(const PlayAnimationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayAnimationResponse& operator=(PlayAnimationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayAnimationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayAnimationResponse* internal_default_instance() {
    return reinterpret_cast<const PlayAnimationResponse*>(
               &_PlayAnimationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PlayAnimationResponse& a, PlayAnimationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayAnimationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayAnimationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayAnimationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayAnimationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayAnimationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlayAnimationResponse& from) {
    PlayAnimationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayAnimationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.PlayAnimationResponse";
  }
  protected:
  explicit PlayAnimationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 1,
    kNumberOfFramesQueuedFieldNumber = 2,
  };
  // string status = 1;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // int32 number_of_frames_queued = 2;
  void clear_number_of_frames_queued();
  int32_t number_of_frames_queued() const;
  void set_number_of_frames_queued(int32_t value);
  private:
  int32_t _internal_number_of_frames_queued() const;
  void _internal_set_number_of_frames_queued(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:server.PlayAnimationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
    int32_t number_of_frames_queued_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreatureIdentifier

// bytes _id = 1;
inline void CreatureIdentifier::clear__id() {
  _impl_._id_.ClearToEmpty();
}
inline const std::string& CreatureIdentifier::_id() const {
  // @@protoc_insertion_point(field_get:server.CreatureIdentifier._id)
  return _internal__id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatureIdentifier::set__id(ArgT0&& arg0, ArgT... args) {
 
 _impl_._id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.CreatureIdentifier._id)
}
inline std::string* CreatureIdentifier::mutable__id() {
  std::string* _s = _internal_mutable__id();
  // @@protoc_insertion_point(field_mutable:server.CreatureIdentifier._id)
  return _s;
}
inline const std::string& CreatureIdentifier::_internal__id() const {
  return _impl_._id_.Get();
}
inline void CreatureIdentifier::_internal_set__id(const std::string& value) {
  
  _impl_._id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreatureIdentifier::_internal_mutable__id() {
  
  return _impl_._id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreatureIdentifier::release__id() {
  // @@protoc_insertion_point(field_release:server.CreatureIdentifier._id)
  return _impl_._id_.Release();
}
inline void CreatureIdentifier::set_allocated__id(std::string* _id) {
  if (_id != nullptr) {
    
  } else {
    
  }
  _impl_._id_.SetAllocated(_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._id_.IsDefault()) {
    _impl_._id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.CreatureIdentifier._id)
}

// string name = 2;
inline void CreatureIdentifier::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreatureIdentifier::name() const {
  // @@protoc_insertion_point(field_get:server.CreatureIdentifier.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatureIdentifier::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.CreatureIdentifier.name)
}
inline std::string* CreatureIdentifier::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:server.CreatureIdentifier.name)
  return _s;
}
inline const std::string& CreatureIdentifier::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreatureIdentifier::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreatureIdentifier::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreatureIdentifier::release_name() {
  // @@protoc_insertion_point(field_release:server.CreatureIdentifier.name)
  return _impl_.name_.Release();
}
inline void CreatureIdentifier::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.CreatureIdentifier.name)
}

// -------------------------------------------------------------------

// ListCreaturesResponse

// repeated .server.CreatureIdentifier creaturesIds = 1;
inline int ListCreaturesResponse::_internal_creaturesids_size() const {
  return _impl_.creaturesids_.size();
}
inline int ListCreaturesResponse::creaturesids_size() const {
  return _internal_creaturesids_size();
}
inline void ListCreaturesResponse::clear_creaturesids() {
  _impl_.creaturesids_.Clear();
}
inline ::server::CreatureIdentifier* ListCreaturesResponse::mutable_creaturesids(int index) {
  // @@protoc_insertion_point(field_mutable:server.ListCreaturesResponse.creaturesIds)
  return _impl_.creaturesids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::CreatureIdentifier >*
ListCreaturesResponse::mutable_creaturesids() {
  // @@protoc_insertion_point(field_mutable_list:server.ListCreaturesResponse.creaturesIds)
  return &_impl_.creaturesids_;
}
inline const ::server::CreatureIdentifier& ListCreaturesResponse::_internal_creaturesids(int index) const {
  return _impl_.creaturesids_.Get(index);
}
inline const ::server::CreatureIdentifier& ListCreaturesResponse::creaturesids(int index) const {
  // @@protoc_insertion_point(field_get:server.ListCreaturesResponse.creaturesIds)
  return _internal_creaturesids(index);
}
inline ::server::CreatureIdentifier* ListCreaturesResponse::_internal_add_creaturesids() {
  return _impl_.creaturesids_.Add();
}
inline ::server::CreatureIdentifier* ListCreaturesResponse::add_creaturesids() {
  ::server::CreatureIdentifier* _add = _internal_add_creaturesids();
  // @@protoc_insertion_point(field_add:server.ListCreaturesResponse.creaturesIds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::CreatureIdentifier >&
ListCreaturesResponse::creaturesids() const {
  // @@protoc_insertion_point(field_list:server.ListCreaturesResponse.creaturesIds)
  return _impl_.creaturesids_;
}

// -------------------------------------------------------------------

// GetAllCreaturesResponse

// repeated .server.Creature creatures = 1;
inline int GetAllCreaturesResponse::_internal_creatures_size() const {
  return _impl_.creatures_.size();
}
inline int GetAllCreaturesResponse::creatures_size() const {
  return _internal_creatures_size();
}
inline void GetAllCreaturesResponse::clear_creatures() {
  _impl_.creatures_.Clear();
}
inline ::server::Creature* GetAllCreaturesResponse::mutable_creatures(int index) {
  // @@protoc_insertion_point(field_mutable:server.GetAllCreaturesResponse.creatures)
  return _impl_.creatures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature >*
GetAllCreaturesResponse::mutable_creatures() {
  // @@protoc_insertion_point(field_mutable_list:server.GetAllCreaturesResponse.creatures)
  return &_impl_.creatures_;
}
inline const ::server::Creature& GetAllCreaturesResponse::_internal_creatures(int index) const {
  return _impl_.creatures_.Get(index);
}
inline const ::server::Creature& GetAllCreaturesResponse::creatures(int index) const {
  // @@protoc_insertion_point(field_get:server.GetAllCreaturesResponse.creatures)
  return _internal_creatures(index);
}
inline ::server::Creature* GetAllCreaturesResponse::_internal_add_creatures() {
  return _impl_.creatures_.Add();
}
inline ::server::Creature* GetAllCreaturesResponse::add_creatures() {
  ::server::Creature* _add = _internal_add_creatures();
  // @@protoc_insertion_point(field_add:server.GetAllCreaturesResponse.creatures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature >&
GetAllCreaturesResponse::creatures() const {
  // @@protoc_insertion_point(field_list:server.GetAllCreaturesResponse.creatures)
  return _impl_.creatures_;
}

// -------------------------------------------------------------------

// CreatureFilter

// string filter = 1;
inline void CreatureFilter::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& CreatureFilter::filter() const {
  // @@protoc_insertion_point(field_get:server.CreatureFilter.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatureFilter::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.CreatureFilter.filter)
}
inline std::string* CreatureFilter::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:server.CreatureFilter.filter)
  return _s;
}
inline const std::string& CreatureFilter::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void CreatureFilter::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* CreatureFilter::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* CreatureFilter::release_filter() {
  // @@protoc_insertion_point(field_release:server.CreatureFilter.filter)
  return _impl_.filter_.Release();
}
inline void CreatureFilter::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.CreatureFilter.filter)
}

// .server.SortBy sortBy = 2;
inline void CreatureFilter::clear_sortby() {
  _impl_.sortby_ = 0;
}
inline ::server::SortBy CreatureFilter::_internal_sortby() const {
  return static_cast< ::server::SortBy >(_impl_.sortby_);
}
inline ::server::SortBy CreatureFilter::sortby() const {
  // @@protoc_insertion_point(field_get:server.CreatureFilter.sortBy)
  return _internal_sortby();
}
inline void CreatureFilter::_internal_set_sortby(::server::SortBy value) {
  
  _impl_.sortby_ = value;
}
inline void CreatureFilter::set_sortby(::server::SortBy value) {
  _internal_set_sortby(value);
  // @@protoc_insertion_point(field_set:server.CreatureFilter.sortBy)
}

// -------------------------------------------------------------------

// DatabaseInfo

// string message = 1;
inline void DatabaseInfo::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& DatabaseInfo::message() const {
  // @@protoc_insertion_point(field_get:server.DatabaseInfo.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatabaseInfo::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.DatabaseInfo.message)
}
inline std::string* DatabaseInfo::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:server.DatabaseInfo.message)
  return _s;
}
inline const std::string& DatabaseInfo::_internal_message() const {
  return _impl_.message_.Get();
}
inline void DatabaseInfo::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* DatabaseInfo::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* DatabaseInfo::release_message() {
  // @@protoc_insertion_point(field_release:server.DatabaseInfo.message)
  return _impl_.message_.Release();
}
inline void DatabaseInfo::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.DatabaseInfo.message)
}

// string help = 2;
inline void DatabaseInfo::clear_help() {
  _impl_.help_.ClearToEmpty();
}
inline const std::string& DatabaseInfo::help() const {
  // @@protoc_insertion_point(field_get:server.DatabaseInfo.help)
  return _internal_help();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatabaseInfo::set_help(ArgT0&& arg0, ArgT... args) {
 
 _impl_.help_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.DatabaseInfo.help)
}
inline std::string* DatabaseInfo::mutable_help() {
  std::string* _s = _internal_mutable_help();
  // @@protoc_insertion_point(field_mutable:server.DatabaseInfo.help)
  return _s;
}
inline const std::string& DatabaseInfo::_internal_help() const {
  return _impl_.help_.Get();
}
inline void DatabaseInfo::_internal_set_help(const std::string& value) {
  
  _impl_.help_.Set(value, GetArenaForAllocation());
}
inline std::string* DatabaseInfo::_internal_mutable_help() {
  
  return _impl_.help_.Mutable(GetArenaForAllocation());
}
inline std::string* DatabaseInfo::release_help() {
  // @@protoc_insertion_point(field_release:server.DatabaseInfo.help)
  return _impl_.help_.Release();
}
inline void DatabaseInfo::set_allocated_help(std::string* help) {
  if (help != nullptr) {
    
  } else {
    
  }
  _impl_.help_.SetAllocated(help, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.help_.IsDefault()) {
    _impl_.help_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.DatabaseInfo.help)
}

// -------------------------------------------------------------------

// LogFilter

// .server.LogLevel level = 1;
inline void LogFilter::clear_level() {
  _impl_.level_ = 0;
}
inline ::server::LogLevel LogFilter::_internal_level() const {
  return static_cast< ::server::LogLevel >(_impl_.level_);
}
inline ::server::LogLevel LogFilter::level() const {
  // @@protoc_insertion_point(field_get:server.LogFilter.level)
  return _internal_level();
}
inline void LogFilter::_internal_set_level(::server::LogLevel value) {
  
  _impl_.level_ = value;
}
inline void LogFilter::set_level(::server::LogLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:server.LogFilter.level)
}

// -------------------------------------------------------------------

// CreatureId

// bytes _id = 1;
inline void CreatureId::clear__id() {
  _impl_._id_.ClearToEmpty();
}
inline const std::string& CreatureId::_id() const {
  // @@protoc_insertion_point(field_get:server.CreatureId._id)
  return _internal__id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatureId::set__id(ArgT0&& arg0, ArgT... args) {
 
 _impl_._id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.CreatureId._id)
}
inline std::string* CreatureId::mutable__id() {
  std::string* _s = _internal_mutable__id();
  // @@protoc_insertion_point(field_mutable:server.CreatureId._id)
  return _s;
}
inline const std::string& CreatureId::_internal__id() const {
  return _impl_._id_.Get();
}
inline void CreatureId::_internal_set__id(const std::string& value) {
  
  _impl_._id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreatureId::_internal_mutable__id() {
  
  return _impl_._id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreatureId::release__id() {
  // @@protoc_insertion_point(field_release:server.CreatureId._id)
  return _impl_._id_.Release();
}
inline void CreatureId::set_allocated__id(std::string* _id) {
  if (_id != nullptr) {
    
  } else {
    
  }
  _impl_._id_.SetAllocated(_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._id_.IsDefault()) {
    _impl_._id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.CreatureId._id)
}

// -------------------------------------------------------------------

// CreatureName

// string name = 1;
inline void CreatureName::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreatureName::name() const {
  // @@protoc_insertion_point(field_get:server.CreatureName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatureName::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.CreatureName.name)
}
inline std::string* CreatureName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:server.CreatureName.name)
  return _s;
}
inline const std::string& CreatureName::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreatureName::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreatureName::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreatureName::release_name() {
  // @@protoc_insertion_point(field_release:server.CreatureName.name)
  return _impl_.name_.Release();
}
inline void CreatureName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.CreatureName.name)
}

// -------------------------------------------------------------------

// Creature_Motor

// bytes _id = 1;
inline void Creature_Motor::clear__id() {
  _impl_._id_.ClearToEmpty();
}
inline const std::string& Creature_Motor::_id() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor._id)
  return _internal__id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Creature_Motor::set__id(ArgT0&& arg0, ArgT... args) {
 
 _impl_._id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Creature.Motor._id)
}
inline std::string* Creature_Motor::mutable__id() {
  std::string* _s = _internal_mutable__id();
  // @@protoc_insertion_point(field_mutable:server.Creature.Motor._id)
  return _s;
}
inline const std::string& Creature_Motor::_internal__id() const {
  return _impl_._id_.Get();
}
inline void Creature_Motor::_internal_set__id(const std::string& value) {
  
  _impl_._id_.Set(value, GetArenaForAllocation());
}
inline std::string* Creature_Motor::_internal_mutable__id() {
  
  return _impl_._id_.Mutable(GetArenaForAllocation());
}
inline std::string* Creature_Motor::release__id() {
  // @@protoc_insertion_point(field_release:server.Creature.Motor._id)
  return _impl_._id_.Release();
}
inline void Creature_Motor::set_allocated__id(std::string* _id) {
  if (_id != nullptr) {
    
  } else {
    
  }
  _impl_._id_.SetAllocated(_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._id_.IsDefault()) {
    _impl_._id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Creature.Motor._id)
}

// string name = 2;
inline void Creature_Motor::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Creature_Motor::name() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Creature_Motor::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Creature.Motor.name)
}
inline std::string* Creature_Motor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:server.Creature.Motor.name)
  return _s;
}
inline const std::string& Creature_Motor::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Creature_Motor::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Creature_Motor::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Creature_Motor::release_name() {
  // @@protoc_insertion_point(field_release:server.Creature.Motor.name)
  return _impl_.name_.Release();
}
inline void Creature_Motor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Creature.Motor.name)
}

// .server.Creature.MotorType type = 3;
inline void Creature_Motor::clear_type() {
  _impl_.type_ = 0;
}
inline ::server::Creature_MotorType Creature_Motor::_internal_type() const {
  return static_cast< ::server::Creature_MotorType >(_impl_.type_);
}
inline ::server::Creature_MotorType Creature_Motor::type() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.type)
  return _internal_type();
}
inline void Creature_Motor::_internal_set_type(::server::Creature_MotorType value) {
  
  _impl_.type_ = value;
}
inline void Creature_Motor::set_type(::server::Creature_MotorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.type)
}

// uint32 number = 4;
inline void Creature_Motor::clear_number() {
  _impl_.number_ = 0u;
}
inline uint32_t Creature_Motor::_internal_number() const {
  return _impl_.number_;
}
inline uint32_t Creature_Motor::number() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.number)
  return _internal_number();
}
inline void Creature_Motor::_internal_set_number(uint32_t value) {
  
  _impl_.number_ = value;
}
inline void Creature_Motor::set_number(uint32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.number)
}

// uint32 max_value = 5;
inline void Creature_Motor::clear_max_value() {
  _impl_.max_value_ = 0u;
}
inline uint32_t Creature_Motor::_internal_max_value() const {
  return _impl_.max_value_;
}
inline uint32_t Creature_Motor::max_value() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.max_value)
  return _internal_max_value();
}
inline void Creature_Motor::_internal_set_max_value(uint32_t value) {
  
  _impl_.max_value_ = value;
}
inline void Creature_Motor::set_max_value(uint32_t value) {
  _internal_set_max_value(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.max_value)
}

// uint32 min_value = 6;
inline void Creature_Motor::clear_min_value() {
  _impl_.min_value_ = 0u;
}
inline uint32_t Creature_Motor::_internal_min_value() const {
  return _impl_.min_value_;
}
inline uint32_t Creature_Motor::min_value() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.min_value)
  return _internal_min_value();
}
inline void Creature_Motor::_internal_set_min_value(uint32_t value) {
  
  _impl_.min_value_ = value;
}
inline void Creature_Motor::set_min_value(uint32_t value) {
  _internal_set_min_value(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.min_value)
}

// double smoothing_value = 7;
inline void Creature_Motor::clear_smoothing_value() {
  _impl_.smoothing_value_ = 0;
}
inline double Creature_Motor::_internal_smoothing_value() const {
  return _impl_.smoothing_value_;
}
inline double Creature_Motor::smoothing_value() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.smoothing_value)
  return _internal_smoothing_value();
}
inline void Creature_Motor::_internal_set_smoothing_value(double value) {
  
  _impl_.smoothing_value_ = value;
}
inline void Creature_Motor::set_smoothing_value(double value) {
  _internal_set_smoothing_value(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.smoothing_value)
}

// -------------------------------------------------------------------

// Creature

// bytes _id = 1;
inline void Creature::clear__id() {
  _impl_._id_.ClearToEmpty();
}
inline const std::string& Creature::_id() const {
  // @@protoc_insertion_point(field_get:server.Creature._id)
  return _internal__id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Creature::set__id(ArgT0&& arg0, ArgT... args) {
 
 _impl_._id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Creature._id)
}
inline std::string* Creature::mutable__id() {
  std::string* _s = _internal_mutable__id();
  // @@protoc_insertion_point(field_mutable:server.Creature._id)
  return _s;
}
inline const std::string& Creature::_internal__id() const {
  return _impl_._id_.Get();
}
inline void Creature::_internal_set__id(const std::string& value) {
  
  _impl_._id_.Set(value, GetArenaForAllocation());
}
inline std::string* Creature::_internal_mutable__id() {
  
  return _impl_._id_.Mutable(GetArenaForAllocation());
}
inline std::string* Creature::release__id() {
  // @@protoc_insertion_point(field_release:server.Creature._id)
  return _impl_._id_.Release();
}
inline void Creature::set_allocated__id(std::string* _id) {
  if (_id != nullptr) {
    
  } else {
    
  }
  _impl_._id_.SetAllocated(_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._id_.IsDefault()) {
    _impl_._id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Creature._id)
}

// string name = 2;
inline void Creature::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Creature::name() const {
  // @@protoc_insertion_point(field_get:server.Creature.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Creature::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Creature.name)
}
inline std::string* Creature::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:server.Creature.name)
  return _s;
}
inline const std::string& Creature::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Creature::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Creature::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Creature::release_name() {
  // @@protoc_insertion_point(field_release:server.Creature.name)
  return _impl_.name_.Release();
}
inline void Creature::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Creature.name)
}

// .google.protobuf.Timestamp last_updated = 3;
inline bool Creature::_internal_has_last_updated() const {
  return this != internal_default_instance() && _impl_.last_updated_ != nullptr;
}
inline bool Creature::has_last_updated() const {
  return _internal_has_last_updated();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Creature::_internal_last_updated() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_updated_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Creature::last_updated() const {
  // @@protoc_insertion_point(field_get:server.Creature.last_updated)
  return _internal_last_updated();
}
inline void Creature::unsafe_arena_set_allocated_last_updated(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_updated_);
  }
  _impl_.last_updated_ = last_updated;
  if (last_updated) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:server.Creature.last_updated)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Creature::release_last_updated() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_updated_;
  _impl_.last_updated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Creature::unsafe_arena_release_last_updated() {
  // @@protoc_insertion_point(field_release:server.Creature.last_updated)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_updated_;
  _impl_.last_updated_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Creature::_internal_mutable_last_updated() {
  
  if (_impl_.last_updated_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_updated_ = p;
  }
  return _impl_.last_updated_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Creature::mutable_last_updated() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_updated();
  // @@protoc_insertion_point(field_mutable:server.Creature.last_updated)
  return _msg;
}
inline void Creature::set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_updated_);
  }
  if (last_updated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated));
    if (message_arena != submessage_arena) {
      last_updated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_updated, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_updated_ = last_updated;
  // @@protoc_insertion_point(field_set_allocated:server.Creature.last_updated)
}

// string sacn_ip = 4;
inline void Creature::clear_sacn_ip() {
  _impl_.sacn_ip_.ClearToEmpty();
}
inline const std::string& Creature::sacn_ip() const {
  // @@protoc_insertion_point(field_get:server.Creature.sacn_ip)
  return _internal_sacn_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Creature::set_sacn_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sacn_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Creature.sacn_ip)
}
inline std::string* Creature::mutable_sacn_ip() {
  std::string* _s = _internal_mutable_sacn_ip();
  // @@protoc_insertion_point(field_mutable:server.Creature.sacn_ip)
  return _s;
}
inline const std::string& Creature::_internal_sacn_ip() const {
  return _impl_.sacn_ip_.Get();
}
inline void Creature::_internal_set_sacn_ip(const std::string& value) {
  
  _impl_.sacn_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Creature::_internal_mutable_sacn_ip() {
  
  return _impl_.sacn_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* Creature::release_sacn_ip() {
  // @@protoc_insertion_point(field_release:server.Creature.sacn_ip)
  return _impl_.sacn_ip_.Release();
}
inline void Creature::set_allocated_sacn_ip(std::string* sacn_ip) {
  if (sacn_ip != nullptr) {
    
  } else {
    
  }
  _impl_.sacn_ip_.SetAllocated(sacn_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sacn_ip_.IsDefault()) {
    _impl_.sacn_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Creature.sacn_ip)
}

// uint32 universe = 5;
inline void Creature::clear_universe() {
  _impl_.universe_ = 0u;
}
inline uint32_t Creature::_internal_universe() const {
  return _impl_.universe_;
}
inline uint32_t Creature::universe() const {
  // @@protoc_insertion_point(field_get:server.Creature.universe)
  return _internal_universe();
}
inline void Creature::_internal_set_universe(uint32_t value) {
  
  _impl_.universe_ = value;
}
inline void Creature::set_universe(uint32_t value) {
  _internal_set_universe(value);
  // @@protoc_insertion_point(field_set:server.Creature.universe)
}

// uint32 dmx_base = 6;
inline void Creature::clear_dmx_base() {
  _impl_.dmx_base_ = 0u;
}
inline uint32_t Creature::_internal_dmx_base() const {
  return _impl_.dmx_base_;
}
inline uint32_t Creature::dmx_base() const {
  // @@protoc_insertion_point(field_get:server.Creature.dmx_base)
  return _internal_dmx_base();
}
inline void Creature::_internal_set_dmx_base(uint32_t value) {
  
  _impl_.dmx_base_ = value;
}
inline void Creature::set_dmx_base(uint32_t value) {
  _internal_set_dmx_base(value);
  // @@protoc_insertion_point(field_set:server.Creature.dmx_base)
}

// uint32 number_of_motors = 7;
inline void Creature::clear_number_of_motors() {
  _impl_.number_of_motors_ = 0u;
}
inline uint32_t Creature::_internal_number_of_motors() const {
  return _impl_.number_of_motors_;
}
inline uint32_t Creature::number_of_motors() const {
  // @@protoc_insertion_point(field_get:server.Creature.number_of_motors)
  return _internal_number_of_motors();
}
inline void Creature::_internal_set_number_of_motors(uint32_t value) {
  
  _impl_.number_of_motors_ = value;
}
inline void Creature::set_number_of_motors(uint32_t value) {
  _internal_set_number_of_motors(value);
  // @@protoc_insertion_point(field_set:server.Creature.number_of_motors)
}

// .server.CreatureType type = 8;
inline void Creature::clear_type() {
  _impl_.type_ = 0;
}
inline ::server::CreatureType Creature::_internal_type() const {
  return static_cast< ::server::CreatureType >(_impl_.type_);
}
inline ::server::CreatureType Creature::type() const {
  // @@protoc_insertion_point(field_get:server.Creature.type)
  return _internal_type();
}
inline void Creature::_internal_set_type(::server::CreatureType value) {
  
  _impl_.type_ = value;
}
inline void Creature::set_type(::server::CreatureType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:server.Creature.type)
}

// repeated .server.Creature.Motor motors = 90;
inline int Creature::_internal_motors_size() const {
  return _impl_.motors_.size();
}
inline int Creature::motors_size() const {
  return _internal_motors_size();
}
inline void Creature::clear_motors() {
  _impl_.motors_.Clear();
}
inline ::server::Creature_Motor* Creature::mutable_motors(int index) {
  // @@protoc_insertion_point(field_mutable:server.Creature.motors)
  return _impl_.motors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor >*
Creature::mutable_motors() {
  // @@protoc_insertion_point(field_mutable_list:server.Creature.motors)
  return &_impl_.motors_;
}
inline const ::server::Creature_Motor& Creature::_internal_motors(int index) const {
  return _impl_.motors_.Get(index);
}
inline const ::server::Creature_Motor& Creature::motors(int index) const {
  // @@protoc_insertion_point(field_get:server.Creature.motors)
  return _internal_motors(index);
}
inline ::server::Creature_Motor* Creature::_internal_add_motors() {
  return _impl_.motors_.Add();
}
inline ::server::Creature_Motor* Creature::add_motors() {
  ::server::Creature_Motor* _add = _internal_add_motors();
  // @@protoc_insertion_point(field_add:server.Creature.motors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor >&
Creature::motors() const {
  // @@protoc_insertion_point(field_list:server.Creature.motors)
  return _impl_.motors_;
}

// -------------------------------------------------------------------

// LogItem

// .server.LogLevel level = 1;
inline void LogItem::clear_level() {
  _impl_.level_ = 0;
}
inline ::server::LogLevel LogItem::_internal_level() const {
  return static_cast< ::server::LogLevel >(_impl_.level_);
}
inline ::server::LogLevel LogItem::level() const {
  // @@protoc_insertion_point(field_get:server.LogItem.level)
  return _internal_level();
}
inline void LogItem::_internal_set_level(::server::LogLevel value) {
  
  _impl_.level_ = value;
}
inline void LogItem::set_level(::server::LogLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:server.LogItem.level)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool LogItem::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool LogItem::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogItem::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogItem::timestamp() const {
  // @@protoc_insertion_point(field_get:server.LogItem.timestamp)
  return _internal_timestamp();
}
inline void LogItem::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:server.LogItem.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogItem::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogItem::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:server.LogItem.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogItem::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogItem::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:server.LogItem.timestamp)
  return _msg;
}
inline void LogItem::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:server.LogItem.timestamp)
}

// string message = 3;
inline void LogItem::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LogItem::message() const {
  // @@protoc_insertion_point(field_get:server.LogItem.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogItem::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.LogItem.message)
}
inline std::string* LogItem::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:server.LogItem.message)
  return _s;
}
inline const std::string& LogItem::_internal_message() const {
  return _impl_.message_.Get();
}
inline void LogItem::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* LogItem::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* LogItem::release_message() {
  // @@protoc_insertion_point(field_release:server.LogItem.message)
  return _impl_.message_.Release();
}
inline void LogItem::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.LogItem.message)
}

// string logger_name = 4;
inline void LogItem::clear_logger_name() {
  _impl_.logger_name_.ClearToEmpty();
}
inline const std::string& LogItem::logger_name() const {
  // @@protoc_insertion_point(field_get:server.LogItem.logger_name)
  return _internal_logger_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogItem::set_logger_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.logger_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.LogItem.logger_name)
}
inline std::string* LogItem::mutable_logger_name() {
  std::string* _s = _internal_mutable_logger_name();
  // @@protoc_insertion_point(field_mutable:server.LogItem.logger_name)
  return _s;
}
inline const std::string& LogItem::_internal_logger_name() const {
  return _impl_.logger_name_.Get();
}
inline void LogItem::_internal_set_logger_name(const std::string& value) {
  
  _impl_.logger_name_.Set(value, GetArenaForAllocation());
}
inline std::string* LogItem::_internal_mutable_logger_name() {
  
  return _impl_.logger_name_.Mutable(GetArenaForAllocation());
}
inline std::string* LogItem::release_logger_name() {
  // @@protoc_insertion_point(field_release:server.LogItem.logger_name)
  return _impl_.logger_name_.Release();
}
inline void LogItem::set_allocated_logger_name(std::string* logger_name) {
  if (logger_name != nullptr) {
    
  } else {
    
  }
  _impl_.logger_name_.SetAllocated(logger_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.logger_name_.IsDefault()) {
    _impl_.logger_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.LogItem.logger_name)
}

// uint32 thread_id = 5;
inline void LogItem::clear_thread_id() {
  _impl_.thread_id_ = 0u;
}
inline uint32_t LogItem::_internal_thread_id() const {
  return _impl_.thread_id_;
}
inline uint32_t LogItem::thread_id() const {
  // @@protoc_insertion_point(field_get:server.LogItem.thread_id)
  return _internal_thread_id();
}
inline void LogItem::_internal_set_thread_id(uint32_t value) {
  
  _impl_.thread_id_ = value;
}
inline void LogItem::set_thread_id(uint32_t value) {
  _internal_set_thread_id(value);
  // @@protoc_insertion_point(field_set:server.LogItem.thread_id)
}

// -------------------------------------------------------------------

// Frame

// uint32 universe = 1;
inline void Frame::clear_universe() {
  _impl_.universe_ = 0u;
}
inline uint32_t Frame::_internal_universe() const {
  return _impl_.universe_;
}
inline uint32_t Frame::universe() const {
  // @@protoc_insertion_point(field_get:server.Frame.universe)
  return _internal_universe();
}
inline void Frame::_internal_set_universe(uint32_t value) {
  
  _impl_.universe_ = value;
}
inline void Frame::set_universe(uint32_t value) {
  _internal_set_universe(value);
  // @@protoc_insertion_point(field_set:server.Frame.universe)
}

// uint32 dmx_offset = 2;
inline void Frame::clear_dmx_offset() {
  _impl_.dmx_offset_ = 0u;
}
inline uint32_t Frame::_internal_dmx_offset() const {
  return _impl_.dmx_offset_;
}
inline uint32_t Frame::dmx_offset() const {
  // @@protoc_insertion_point(field_get:server.Frame.dmx_offset)
  return _internal_dmx_offset();
}
inline void Frame::_internal_set_dmx_offset(uint32_t value) {
  
  _impl_.dmx_offset_ = value;
}
inline void Frame::set_dmx_offset(uint32_t value) {
  _internal_set_dmx_offset(value);
  // @@protoc_insertion_point(field_set:server.Frame.dmx_offset)
}

// string creature_name = 3;
inline void Frame::clear_creature_name() {
  _impl_.creature_name_.ClearToEmpty();
}
inline const std::string& Frame::creature_name() const {
  // @@protoc_insertion_point(field_get:server.Frame.creature_name)
  return _internal_creature_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Frame::set_creature_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.creature_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Frame.creature_name)
}
inline std::string* Frame::mutable_creature_name() {
  std::string* _s = _internal_mutable_creature_name();
  // @@protoc_insertion_point(field_mutable:server.Frame.creature_name)
  return _s;
}
inline const std::string& Frame::_internal_creature_name() const {
  return _impl_.creature_name_.Get();
}
inline void Frame::_internal_set_creature_name(const std::string& value) {
  
  _impl_.creature_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Frame::_internal_mutable_creature_name() {
  
  return _impl_.creature_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Frame::release_creature_name() {
  // @@protoc_insertion_point(field_release:server.Frame.creature_name)
  return _impl_.creature_name_.Release();
}
inline void Frame::set_allocated_creature_name(std::string* creature_name) {
  if (creature_name != nullptr) {
    
  } else {
    
  }
  _impl_.creature_name_.SetAllocated(creature_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creature_name_.IsDefault()) {
    _impl_.creature_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Frame.creature_name)
}

// string sacn_ip = 4;
inline void Frame::clear_sacn_ip() {
  _impl_.sacn_ip_.ClearToEmpty();
}
inline const std::string& Frame::sacn_ip() const {
  // @@protoc_insertion_point(field_get:server.Frame.sacn_ip)
  return _internal_sacn_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Frame::set_sacn_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sacn_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Frame.sacn_ip)
}
inline std::string* Frame::mutable_sacn_ip() {
  std::string* _s = _internal_mutable_sacn_ip();
  // @@protoc_insertion_point(field_mutable:server.Frame.sacn_ip)
  return _s;
}
inline const std::string& Frame::_internal_sacn_ip() const {
  return _impl_.sacn_ip_.Get();
}
inline void Frame::_internal_set_sacn_ip(const std::string& value) {
  
  _impl_.sacn_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Frame::_internal_mutable_sacn_ip() {
  
  return _impl_.sacn_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* Frame::release_sacn_ip() {
  // @@protoc_insertion_point(field_release:server.Frame.sacn_ip)
  return _impl_.sacn_ip_.Release();
}
inline void Frame::set_allocated_sacn_ip(std::string* sacn_ip) {
  if (sacn_ip != nullptr) {
    
  } else {
    
  }
  _impl_.sacn_ip_.SetAllocated(sacn_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sacn_ip_.IsDefault()) {
    _impl_.sacn_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Frame.sacn_ip)
}

// uint32 number_of_motors = 5;
inline void Frame::clear_number_of_motors() {
  _impl_.number_of_motors_ = 0u;
}
inline uint32_t Frame::_internal_number_of_motors() const {
  return _impl_.number_of_motors_;
}
inline uint32_t Frame::number_of_motors() const {
  // @@protoc_insertion_point(field_get:server.Frame.number_of_motors)
  return _internal_number_of_motors();
}
inline void Frame::_internal_set_number_of_motors(uint32_t value) {
  
  _impl_.number_of_motors_ = value;
}
inline void Frame::set_number_of_motors(uint32_t value) {
  _internal_set_number_of_motors(value);
  // @@protoc_insertion_point(field_set:server.Frame.number_of_motors)
}

// bytes frame = 10;
inline void Frame::clear_frame() {
  _impl_.frame_.ClearToEmpty();
}
inline const std::string& Frame::frame() const {
  // @@protoc_insertion_point(field_get:server.Frame.frame)
  return _internal_frame();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Frame::set_frame(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Frame.frame)
}
inline std::string* Frame::mutable_frame() {
  std::string* _s = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:server.Frame.frame)
  return _s;
}
inline const std::string& Frame::_internal_frame() const {
  return _impl_.frame_.Get();
}
inline void Frame::_internal_set_frame(const std::string& value) {
  
  _impl_.frame_.Set(value, GetArenaForAllocation());
}
inline std::string* Frame::_internal_mutable_frame() {
  
  return _impl_.frame_.Mutable(GetArenaForAllocation());
}
inline std::string* Frame::release_frame() {
  // @@protoc_insertion_point(field_release:server.Frame.frame)
  return _impl_.frame_.Release();
}
inline void Frame::set_allocated_frame(std::string* frame) {
  if (frame != nullptr) {
    
  } else {
    
  }
  _impl_.frame_.SetAllocated(frame, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_.IsDefault()) {
    _impl_.frame_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Frame.frame)
}

// -------------------------------------------------------------------

// FrameResponse

// uint32 frames_processed = 1;
inline void FrameResponse::clear_frames_processed() {
  _impl_.frames_processed_ = 0u;
}
inline uint32_t FrameResponse::_internal_frames_processed() const {
  return _impl_.frames_processed_;
}
inline uint32_t FrameResponse::frames_processed() const {
  // @@protoc_insertion_point(field_get:server.FrameResponse.frames_processed)
  return _internal_frames_processed();
}
inline void FrameResponse::_internal_set_frames_processed(uint32_t value) {
  
  _impl_.frames_processed_ = value;
}
inline void FrameResponse::set_frames_processed(uint32_t value) {
  _internal_set_frames_processed(value);
  // @@protoc_insertion_point(field_set:server.FrameResponse.frames_processed)
}

// string message = 2;
inline void FrameResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& FrameResponse::message() const {
  // @@protoc_insertion_point(field_get:server.FrameResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrameResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.FrameResponse.message)
}
inline std::string* FrameResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:server.FrameResponse.message)
  return _s;
}
inline const std::string& FrameResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void FrameResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* FrameResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* FrameResponse::release_message() {
  // @@protoc_insertion_point(field_release:server.FrameResponse.message)
  return _impl_.message_.Release();
}
inline void FrameResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.FrameResponse.message)
}

// -------------------------------------------------------------------

// ServerStatus

// uint64 frames_processed = 1;
inline void ServerStatus::clear_frames_processed() {
  _impl_.frames_processed_ = uint64_t{0u};
}
inline uint64_t ServerStatus::_internal_frames_processed() const {
  return _impl_.frames_processed_;
}
inline uint64_t ServerStatus::frames_processed() const {
  // @@protoc_insertion_point(field_get:server.ServerStatus.frames_processed)
  return _internal_frames_processed();
}
inline void ServerStatus::_internal_set_frames_processed(uint64_t value) {
  
  _impl_.frames_processed_ = value;
}
inline void ServerStatus::set_frames_processed(uint64_t value) {
  _internal_set_frames_processed(value);
  // @@protoc_insertion_point(field_set:server.ServerStatus.frames_processed)
}

// .google.protobuf.Timestamp started_at = 2;
inline bool ServerStatus::_internal_has_started_at() const {
  return this != internal_default_instance() && _impl_.started_at_ != nullptr;
}
inline bool ServerStatus::has_started_at() const {
  return _internal_has_started_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServerStatus::_internal_started_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.started_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServerStatus::started_at() const {
  // @@protoc_insertion_point(field_get:server.ServerStatus.started_at)
  return _internal_started_at();
}
inline void ServerStatus::unsafe_arena_set_allocated_started_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.started_at_);
  }
  _impl_.started_at_ = started_at;
  if (started_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:server.ServerStatus.started_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServerStatus::release_started_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.started_at_;
  _impl_.started_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServerStatus::unsafe_arena_release_started_at() {
  // @@protoc_insertion_point(field_release:server.ServerStatus.started_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.started_at_;
  _impl_.started_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServerStatus::_internal_mutable_started_at() {
  
  if (_impl_.started_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.started_at_ = p;
  }
  return _impl_.started_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServerStatus::mutable_started_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_started_at();
  // @@protoc_insertion_point(field_mutable:server.ServerStatus.started_at)
  return _msg;
}
inline void ServerStatus::set_allocated_started_at(::PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.started_at_);
  }
  if (started_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at));
    if (message_arena != submessage_arena) {
      started_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, started_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.started_at_ = started_at;
  // @@protoc_insertion_point(field_set_allocated:server.ServerStatus.started_at)
}

// -------------------------------------------------------------------

// Animation_Metadata

// string title = 1;
inline void Animation_Metadata::clear_title() {
  _impl_.title_.ClearToEmpty();
}
inline const std::string& Animation_Metadata::title() const {
  // @@protoc_insertion_point(field_get:server.Animation.Metadata.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Animation_Metadata::set_title(ArgT0&& arg0, ArgT... args) {
 
 _impl_.title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Animation.Metadata.title)
}
inline std::string* Animation_Metadata::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:server.Animation.Metadata.title)
  return _s;
}
inline const std::string& Animation_Metadata::_internal_title() const {
  return _impl_.title_.Get();
}
inline void Animation_Metadata::_internal_set_title(const std::string& value) {
  
  _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* Animation_Metadata::_internal_mutable_title() {
  
  return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* Animation_Metadata::release_title() {
  // @@protoc_insertion_point(field_release:server.Animation.Metadata.title)
  return _impl_.title_.Release();
}
inline void Animation_Metadata::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.title_.IsDefault()) {
    _impl_.title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Animation.Metadata.title)
}

// int32 milliseconds_per_frame = 2;
inline void Animation_Metadata::clear_milliseconds_per_frame() {
  _impl_.milliseconds_per_frame_ = 0;
}
inline int32_t Animation_Metadata::_internal_milliseconds_per_frame() const {
  return _impl_.milliseconds_per_frame_;
}
inline int32_t Animation_Metadata::milliseconds_per_frame() const {
  // @@protoc_insertion_point(field_get:server.Animation.Metadata.milliseconds_per_frame)
  return _internal_milliseconds_per_frame();
}
inline void Animation_Metadata::_internal_set_milliseconds_per_frame(int32_t value) {
  
  _impl_.milliseconds_per_frame_ = value;
}
inline void Animation_Metadata::set_milliseconds_per_frame(int32_t value) {
  _internal_set_milliseconds_per_frame(value);
  // @@protoc_insertion_point(field_set:server.Animation.Metadata.milliseconds_per_frame)
}

// int32 number_of_frames = 3;
inline void Animation_Metadata::clear_number_of_frames() {
  _impl_.number_of_frames_ = 0;
}
inline int32_t Animation_Metadata::_internal_number_of_frames() const {
  return _impl_.number_of_frames_;
}
inline int32_t Animation_Metadata::number_of_frames() const {
  // @@protoc_insertion_point(field_get:server.Animation.Metadata.number_of_frames)
  return _internal_number_of_frames();
}
inline void Animation_Metadata::_internal_set_number_of_frames(int32_t value) {
  
  _impl_.number_of_frames_ = value;
}
inline void Animation_Metadata::set_number_of_frames(int32_t value) {
  _internal_set_number_of_frames(value);
  // @@protoc_insertion_point(field_set:server.Animation.Metadata.number_of_frames)
}

// .server.CreatureType creature_type = 4;
inline void Animation_Metadata::clear_creature_type() {
  _impl_.creature_type_ = 0;
}
inline ::server::CreatureType Animation_Metadata::_internal_creature_type() const {
  return static_cast< ::server::CreatureType >(_impl_.creature_type_);
}
inline ::server::CreatureType Animation_Metadata::creature_type() const {
  // @@protoc_insertion_point(field_get:server.Animation.Metadata.creature_type)
  return _internal_creature_type();
}
inline void Animation_Metadata::_internal_set_creature_type(::server::CreatureType value) {
  
  _impl_.creature_type_ = value;
}
inline void Animation_Metadata::set_creature_type(::server::CreatureType value) {
  _internal_set_creature_type(value);
  // @@protoc_insertion_point(field_set:server.Animation.Metadata.creature_type)
}

// int32 number_of_motors = 5;
inline void Animation_Metadata::clear_number_of_motors() {
  _impl_.number_of_motors_ = 0;
}
inline int32_t Animation_Metadata::_internal_number_of_motors() const {
  return _impl_.number_of_motors_;
}
inline int32_t Animation_Metadata::number_of_motors() const {
  // @@protoc_insertion_point(field_get:server.Animation.Metadata.number_of_motors)
  return _internal_number_of_motors();
}
inline void Animation_Metadata::_internal_set_number_of_motors(int32_t value) {
  
  _impl_.number_of_motors_ = value;
}
inline void Animation_Metadata::set_number_of_motors(int32_t value) {
  _internal_set_number_of_motors(value);
  // @@protoc_insertion_point(field_set:server.Animation.Metadata.number_of_motors)
}

// string notes = 6;
inline void Animation_Metadata::clear_notes() {
  _impl_.notes_.ClearToEmpty();
}
inline const std::string& Animation_Metadata::notes() const {
  // @@protoc_insertion_point(field_get:server.Animation.Metadata.notes)
  return _internal_notes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Animation_Metadata::set_notes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.notes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Animation.Metadata.notes)
}
inline std::string* Animation_Metadata::mutable_notes() {
  std::string* _s = _internal_mutable_notes();
  // @@protoc_insertion_point(field_mutable:server.Animation.Metadata.notes)
  return _s;
}
inline const std::string& Animation_Metadata::_internal_notes() const {
  return _impl_.notes_.Get();
}
inline void Animation_Metadata::_internal_set_notes(const std::string& value) {
  
  _impl_.notes_.Set(value, GetArenaForAllocation());
}
inline std::string* Animation_Metadata::_internal_mutable_notes() {
  
  return _impl_.notes_.Mutable(GetArenaForAllocation());
}
inline std::string* Animation_Metadata::release_notes() {
  // @@protoc_insertion_point(field_release:server.Animation.Metadata.notes)
  return _impl_.notes_.Release();
}
inline void Animation_Metadata::set_allocated_notes(std::string* notes) {
  if (notes != nullptr) {
    
  } else {
    
  }
  _impl_.notes_.SetAllocated(notes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.notes_.IsDefault()) {
    _impl_.notes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Animation.Metadata.notes)
}

// -------------------------------------------------------------------

// Animation_Frame

// repeated bytes bytes = 1;
inline int Animation_Frame::_internal_bytes_size() const {
  return _impl_.bytes_.size();
}
inline int Animation_Frame::bytes_size() const {
  return _internal_bytes_size();
}
inline void Animation_Frame::clear_bytes() {
  _impl_.bytes_.Clear();
}
inline std::string* Animation_Frame::add_bytes() {
  std::string* _s = _internal_add_bytes();
  // @@protoc_insertion_point(field_add_mutable:server.Animation.Frame.bytes)
  return _s;
}
inline const std::string& Animation_Frame::_internal_bytes(int index) const {
  return _impl_.bytes_.Get(index);
}
inline const std::string& Animation_Frame::bytes(int index) const {
  // @@protoc_insertion_point(field_get:server.Animation.Frame.bytes)
  return _internal_bytes(index);
}
inline std::string* Animation_Frame::mutable_bytes(int index) {
  // @@protoc_insertion_point(field_mutable:server.Animation.Frame.bytes)
  return _impl_.bytes_.Mutable(index);
}
inline void Animation_Frame::set_bytes(int index, const std::string& value) {
  _impl_.bytes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:server.Animation.Frame.bytes)
}
inline void Animation_Frame::set_bytes(int index, std::string&& value) {
  _impl_.bytes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:server.Animation.Frame.bytes)
}
inline void Animation_Frame::set_bytes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bytes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:server.Animation.Frame.bytes)
}
inline void Animation_Frame::set_bytes(int index, const void* value, size_t size) {
  _impl_.bytes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:server.Animation.Frame.bytes)
}
inline std::string* Animation_Frame::_internal_add_bytes() {
  return _impl_.bytes_.Add();
}
inline void Animation_Frame::add_bytes(const std::string& value) {
  _impl_.bytes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:server.Animation.Frame.bytes)
}
inline void Animation_Frame::add_bytes(std::string&& value) {
  _impl_.bytes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:server.Animation.Frame.bytes)
}
inline void Animation_Frame::add_bytes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.bytes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:server.Animation.Frame.bytes)
}
inline void Animation_Frame::add_bytes(const void* value, size_t size) {
  _impl_.bytes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:server.Animation.Frame.bytes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Animation_Frame::bytes() const {
  // @@protoc_insertion_point(field_list:server.Animation.Frame.bytes)
  return _impl_.bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Animation_Frame::mutable_bytes() {
  // @@protoc_insertion_point(field_mutable_list:server.Animation.Frame.bytes)
  return &_impl_.bytes_;
}

// -------------------------------------------------------------------

// Animation

// bytes _id = 1;
inline void Animation::clear__id() {
  _impl_._id_.ClearToEmpty();
}
inline const std::string& Animation::_id() const {
  // @@protoc_insertion_point(field_get:server.Animation._id)
  return _internal__id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Animation::set__id(ArgT0&& arg0, ArgT... args) {
 
 _impl_._id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Animation._id)
}
inline std::string* Animation::mutable__id() {
  std::string* _s = _internal_mutable__id();
  // @@protoc_insertion_point(field_mutable:server.Animation._id)
  return _s;
}
inline const std::string& Animation::_internal__id() const {
  return _impl_._id_.Get();
}
inline void Animation::_internal_set__id(const std::string& value) {
  
  _impl_._id_.Set(value, GetArenaForAllocation());
}
inline std::string* Animation::_internal_mutable__id() {
  
  return _impl_._id_.Mutable(GetArenaForAllocation());
}
inline std::string* Animation::release__id() {
  // @@protoc_insertion_point(field_release:server.Animation._id)
  return _impl_._id_.Release();
}
inline void Animation::set_allocated__id(std::string* _id) {
  if (_id != nullptr) {
    
  } else {
    
  }
  _impl_._id_.SetAllocated(_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._id_.IsDefault()) {
    _impl_._id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Animation._id)
}

// .server.Animation.Metadata metadata = 2;
inline bool Animation::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool Animation::has_metadata() const {
  return _internal_has_metadata();
}
inline void Animation::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::server::Animation_Metadata& Animation::_internal_metadata() const {
  const ::server::Animation_Metadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::server::Animation_Metadata&>(
      ::server::_Animation_Metadata_default_instance_);
}
inline const ::server::Animation_Metadata& Animation::metadata() const {
  // @@protoc_insertion_point(field_get:server.Animation.metadata)
  return _internal_metadata();
}
inline void Animation::unsafe_arena_set_allocated_metadata(
    ::server::Animation_Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:server.Animation.metadata)
}
inline ::server::Animation_Metadata* Animation::release_metadata() {
  
  ::server::Animation_Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::server::Animation_Metadata* Animation::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:server.Animation.metadata)
  
  ::server::Animation_Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::server::Animation_Metadata* Animation::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::server::Animation_Metadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::server::Animation_Metadata* Animation::mutable_metadata() {
  ::server::Animation_Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:server.Animation.metadata)
  return _msg;
}
inline void Animation::set_allocated_metadata(::server::Animation_Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:server.Animation.metadata)
}

// repeated .server.Animation.Frame frames = 3;
inline int Animation::_internal_frames_size() const {
  return _impl_.frames_.size();
}
inline int Animation::frames_size() const {
  return _internal_frames_size();
}
inline void Animation::clear_frames() {
  _impl_.frames_.Clear();
}
inline ::server::Animation_Frame* Animation::mutable_frames(int index) {
  // @@protoc_insertion_point(field_mutable:server.Animation.frames)
  return _impl_.frames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Animation_Frame >*
Animation::mutable_frames() {
  // @@protoc_insertion_point(field_mutable_list:server.Animation.frames)
  return &_impl_.frames_;
}
inline const ::server::Animation_Frame& Animation::_internal_frames(int index) const {
  return _impl_.frames_.Get(index);
}
inline const ::server::Animation_Frame& Animation::frames(int index) const {
  // @@protoc_insertion_point(field_get:server.Animation.frames)
  return _internal_frames(index);
}
inline ::server::Animation_Frame* Animation::_internal_add_frames() {
  return _impl_.frames_.Add();
}
inline ::server::Animation_Frame* Animation::add_frames() {
  ::server::Animation_Frame* _add = _internal_add_frames();
  // @@protoc_insertion_point(field_add:server.Animation.frames)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Animation_Frame >&
Animation::frames() const {
  // @@protoc_insertion_point(field_list:server.Animation.frames)
  return _impl_.frames_;
}

// -------------------------------------------------------------------

// AnimationId

// bytes _id = 1;
inline void AnimationId::clear__id() {
  _impl_._id_.ClearToEmpty();
}
inline const std::string& AnimationId::_id() const {
  // @@protoc_insertion_point(field_get:server.AnimationId._id)
  return _internal__id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnimationId::set__id(ArgT0&& arg0, ArgT... args) {
 
 _impl_._id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.AnimationId._id)
}
inline std::string* AnimationId::mutable__id() {
  std::string* _s = _internal_mutable__id();
  // @@protoc_insertion_point(field_mutable:server.AnimationId._id)
  return _s;
}
inline const std::string& AnimationId::_internal__id() const {
  return _impl_._id_.Get();
}
inline void AnimationId::_internal_set__id(const std::string& value) {
  
  _impl_._id_.Set(value, GetArenaForAllocation());
}
inline std::string* AnimationId::_internal_mutable__id() {
  
  return _impl_._id_.Mutable(GetArenaForAllocation());
}
inline std::string* AnimationId::release__id() {
  // @@protoc_insertion_point(field_release:server.AnimationId._id)
  return _impl_._id_.Release();
}
inline void AnimationId::set_allocated__id(std::string* _id) {
  if (_id != nullptr) {
    
  } else {
    
  }
  _impl_._id_.SetAllocated(_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._id_.IsDefault()) {
    _impl_._id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.AnimationId._id)
}

// -------------------------------------------------------------------

// AnimationFilter

// .server.CreatureType type = 1;
inline void AnimationFilter::clear_type() {
  _impl_.type_ = 0;
}
inline ::server::CreatureType AnimationFilter::_internal_type() const {
  return static_cast< ::server::CreatureType >(_impl_.type_);
}
inline ::server::CreatureType AnimationFilter::type() const {
  // @@protoc_insertion_point(field_get:server.AnimationFilter.type)
  return _internal_type();
}
inline void AnimationFilter::_internal_set_type(::server::CreatureType value) {
  
  _impl_.type_ = value;
}
inline void AnimationFilter::set_type(::server::CreatureType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:server.AnimationFilter.type)
}

// -------------------------------------------------------------------

// ListAnimationsResponse

// repeated .server.AnimationIdentifier animations = 1;
inline int ListAnimationsResponse::_internal_animations_size() const {
  return _impl_.animations_.size();
}
inline int ListAnimationsResponse::animations_size() const {
  return _internal_animations_size();
}
inline void ListAnimationsResponse::clear_animations() {
  _impl_.animations_.Clear();
}
inline ::server::AnimationIdentifier* ListAnimationsResponse::mutable_animations(int index) {
  // @@protoc_insertion_point(field_mutable:server.ListAnimationsResponse.animations)
  return _impl_.animations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::AnimationIdentifier >*
ListAnimationsResponse::mutable_animations() {
  // @@protoc_insertion_point(field_mutable_list:server.ListAnimationsResponse.animations)
  return &_impl_.animations_;
}
inline const ::server::AnimationIdentifier& ListAnimationsResponse::_internal_animations(int index) const {
  return _impl_.animations_.Get(index);
}
inline const ::server::AnimationIdentifier& ListAnimationsResponse::animations(int index) const {
  // @@protoc_insertion_point(field_get:server.ListAnimationsResponse.animations)
  return _internal_animations(index);
}
inline ::server::AnimationIdentifier* ListAnimationsResponse::_internal_add_animations() {
  return _impl_.animations_.Add();
}
inline ::server::AnimationIdentifier* ListAnimationsResponse::add_animations() {
  ::server::AnimationIdentifier* _add = _internal_add_animations();
  // @@protoc_insertion_point(field_add:server.ListAnimationsResponse.animations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::AnimationIdentifier >&
ListAnimationsResponse::animations() const {
  // @@protoc_insertion_point(field_list:server.ListAnimationsResponse.animations)
  return _impl_.animations_;
}

// -------------------------------------------------------------------

// AnimationIdentifier

// bytes _id = 1;
inline void AnimationIdentifier::clear__id() {
  _impl_._id_.ClearToEmpty();
}
inline const std::string& AnimationIdentifier::_id() const {
  // @@protoc_insertion_point(field_get:server.AnimationIdentifier._id)
  return _internal__id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AnimationIdentifier::set__id(ArgT0&& arg0, ArgT... args) {
 
 _impl_._id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.AnimationIdentifier._id)
}
inline std::string* AnimationIdentifier::mutable__id() {
  std::string* _s = _internal_mutable__id();
  // @@protoc_insertion_point(field_mutable:server.AnimationIdentifier._id)
  return _s;
}
inline const std::string& AnimationIdentifier::_internal__id() const {
  return _impl_._id_.Get();
}
inline void AnimationIdentifier::_internal_set__id(const std::string& value) {
  
  _impl_._id_.Set(value, GetArenaForAllocation());
}
inline std::string* AnimationIdentifier::_internal_mutable__id() {
  
  return _impl_._id_.Mutable(GetArenaForAllocation());
}
inline std::string* AnimationIdentifier::release__id() {
  // @@protoc_insertion_point(field_release:server.AnimationIdentifier._id)
  return _impl_._id_.Release();
}
inline void AnimationIdentifier::set_allocated__id(std::string* _id) {
  if (_id != nullptr) {
    
  } else {
    
  }
  _impl_._id_.SetAllocated(_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._id_.IsDefault()) {
    _impl_._id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.AnimationIdentifier._id)
}

// .server.Animation.Metadata metadata = 2;
inline bool AnimationIdentifier::_internal_has_metadata() const {
  return this != internal_default_instance() && _impl_.metadata_ != nullptr;
}
inline bool AnimationIdentifier::has_metadata() const {
  return _internal_has_metadata();
}
inline void AnimationIdentifier::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && _impl_.metadata_ != nullptr) {
    delete _impl_.metadata_;
  }
  _impl_.metadata_ = nullptr;
}
inline const ::server::Animation_Metadata& AnimationIdentifier::_internal_metadata() const {
  const ::server::Animation_Metadata* p = _impl_.metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::server::Animation_Metadata&>(
      ::server::_Animation_Metadata_default_instance_);
}
inline const ::server::Animation_Metadata& AnimationIdentifier::metadata() const {
  // @@protoc_insertion_point(field_get:server.AnimationIdentifier.metadata)
  return _internal_metadata();
}
inline void AnimationIdentifier::unsafe_arena_set_allocated_metadata(
    ::server::Animation_Metadata* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.metadata_);
  }
  _impl_.metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:server.AnimationIdentifier.metadata)
}
inline ::server::Animation_Metadata* AnimationIdentifier::release_metadata() {
  
  ::server::Animation_Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::server::Animation_Metadata* AnimationIdentifier::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:server.AnimationIdentifier.metadata)
  
  ::server::Animation_Metadata* temp = _impl_.metadata_;
  _impl_.metadata_ = nullptr;
  return temp;
}
inline ::server::Animation_Metadata* AnimationIdentifier::_internal_mutable_metadata() {
  
  if (_impl_.metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::server::Animation_Metadata>(GetArenaForAllocation());
    _impl_.metadata_ = p;
  }
  return _impl_.metadata_;
}
inline ::server::Animation_Metadata* AnimationIdentifier::mutable_metadata() {
  ::server::Animation_Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:server.AnimationIdentifier.metadata)
  return _msg;
}
inline void AnimationIdentifier::set_allocated_metadata(::server::Animation_Metadata* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:server.AnimationIdentifier.metadata)
}

// -------------------------------------------------------------------

// PlayAnimationRequest

// .server.CreatureId creatureId = 1;
inline bool PlayAnimationRequest::_internal_has_creatureid() const {
  return this != internal_default_instance() && _impl_.creatureid_ != nullptr;
}
inline bool PlayAnimationRequest::has_creatureid() const {
  return _internal_has_creatureid();
}
inline void PlayAnimationRequest::clear_creatureid() {
  if (GetArenaForAllocation() == nullptr && _impl_.creatureid_ != nullptr) {
    delete _impl_.creatureid_;
  }
  _impl_.creatureid_ = nullptr;
}
inline const ::server::CreatureId& PlayAnimationRequest::_internal_creatureid() const {
  const ::server::CreatureId* p = _impl_.creatureid_;
  return p != nullptr ? *p : reinterpret_cast<const ::server::CreatureId&>(
      ::server::_CreatureId_default_instance_);
}
inline const ::server::CreatureId& PlayAnimationRequest::creatureid() const {
  // @@protoc_insertion_point(field_get:server.PlayAnimationRequest.creatureId)
  return _internal_creatureid();
}
inline void PlayAnimationRequest::unsafe_arena_set_allocated_creatureid(
    ::server::CreatureId* creatureid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.creatureid_);
  }
  _impl_.creatureid_ = creatureid;
  if (creatureid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:server.PlayAnimationRequest.creatureId)
}
inline ::server::CreatureId* PlayAnimationRequest::release_creatureid() {
  
  ::server::CreatureId* temp = _impl_.creatureid_;
  _impl_.creatureid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::server::CreatureId* PlayAnimationRequest::unsafe_arena_release_creatureid() {
  // @@protoc_insertion_point(field_release:server.PlayAnimationRequest.creatureId)
  
  ::server::CreatureId* temp = _impl_.creatureid_;
  _impl_.creatureid_ = nullptr;
  return temp;
}
inline ::server::CreatureId* PlayAnimationRequest::_internal_mutable_creatureid() {
  
  if (_impl_.creatureid_ == nullptr) {
    auto* p = CreateMaybeMessage<::server::CreatureId>(GetArenaForAllocation());
    _impl_.creatureid_ = p;
  }
  return _impl_.creatureid_;
}
inline ::server::CreatureId* PlayAnimationRequest::mutable_creatureid() {
  ::server::CreatureId* _msg = _internal_mutable_creatureid();
  // @@protoc_insertion_point(field_mutable:server.PlayAnimationRequest.creatureId)
  return _msg;
}
inline void PlayAnimationRequest::set_allocated_creatureid(::server::CreatureId* creatureid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.creatureid_;
  }
  if (creatureid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(creatureid);
    if (message_arena != submessage_arena) {
      creatureid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creatureid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.creatureid_ = creatureid;
  // @@protoc_insertion_point(field_set_allocated:server.PlayAnimationRequest.creatureId)
}

// .server.AnimationId animationId = 2;
inline bool PlayAnimationRequest::_internal_has_animationid() const {
  return this != internal_default_instance() && _impl_.animationid_ != nullptr;
}
inline bool PlayAnimationRequest::has_animationid() const {
  return _internal_has_animationid();
}
inline void PlayAnimationRequest::clear_animationid() {
  if (GetArenaForAllocation() == nullptr && _impl_.animationid_ != nullptr) {
    delete _impl_.animationid_;
  }
  _impl_.animationid_ = nullptr;
}
inline const ::server::AnimationId& PlayAnimationRequest::_internal_animationid() const {
  const ::server::AnimationId* p = _impl_.animationid_;
  return p != nullptr ? *p : reinterpret_cast<const ::server::AnimationId&>(
      ::server::_AnimationId_default_instance_);
}
inline const ::server::AnimationId& PlayAnimationRequest::animationid() const {
  // @@protoc_insertion_point(field_get:server.PlayAnimationRequest.animationId)
  return _internal_animationid();
}
inline void PlayAnimationRequest::unsafe_arena_set_allocated_animationid(
    ::server::AnimationId* animationid) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.animationid_);
  }
  _impl_.animationid_ = animationid;
  if (animationid) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:server.PlayAnimationRequest.animationId)
}
inline ::server::AnimationId* PlayAnimationRequest::release_animationid() {
  
  ::server::AnimationId* temp = _impl_.animationid_;
  _impl_.animationid_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::server::AnimationId* PlayAnimationRequest::unsafe_arena_release_animationid() {
  // @@protoc_insertion_point(field_release:server.PlayAnimationRequest.animationId)
  
  ::server::AnimationId* temp = _impl_.animationid_;
  _impl_.animationid_ = nullptr;
  return temp;
}
inline ::server::AnimationId* PlayAnimationRequest::_internal_mutable_animationid() {
  
  if (_impl_.animationid_ == nullptr) {
    auto* p = CreateMaybeMessage<::server::AnimationId>(GetArenaForAllocation());
    _impl_.animationid_ = p;
  }
  return _impl_.animationid_;
}
inline ::server::AnimationId* PlayAnimationRequest::mutable_animationid() {
  ::server::AnimationId* _msg = _internal_mutable_animationid();
  // @@protoc_insertion_point(field_mutable:server.PlayAnimationRequest.animationId)
  return _msg;
}
inline void PlayAnimationRequest::set_allocated_animationid(::server::AnimationId* animationid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.animationid_;
  }
  if (animationid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(animationid);
    if (message_arena != submessage_arena) {
      animationid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, animationid, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.animationid_ = animationid;
  // @@protoc_insertion_point(field_set_allocated:server.PlayAnimationRequest.animationId)
}

// -------------------------------------------------------------------

// PlayAnimationResponse

// string status = 1;
inline void PlayAnimationResponse::clear_status() {
  _impl_.status_.ClearToEmpty();
}
inline const std::string& PlayAnimationResponse::status() const {
  // @@protoc_insertion_point(field_get:server.PlayAnimationResponse.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayAnimationResponse::set_status(ArgT0&& arg0, ArgT... args) {
 
 _impl_.status_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.PlayAnimationResponse.status)
}
inline std::string* PlayAnimationResponse::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:server.PlayAnimationResponse.status)
  return _s;
}
inline const std::string& PlayAnimationResponse::_internal_status() const {
  return _impl_.status_.Get();
}
inline void PlayAnimationResponse::_internal_set_status(const std::string& value) {
  
  _impl_.status_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayAnimationResponse::_internal_mutable_status() {
  
  return _impl_.status_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayAnimationResponse::release_status() {
  // @@protoc_insertion_point(field_release:server.PlayAnimationResponse.status)
  return _impl_.status_.Release();
}
inline void PlayAnimationResponse::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  _impl_.status_.SetAllocated(status, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.status_.IsDefault()) {
    _impl_.status_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.PlayAnimationResponse.status)
}

// int32 number_of_frames_queued = 2;
inline void PlayAnimationResponse::clear_number_of_frames_queued() {
  _impl_.number_of_frames_queued_ = 0;
}
inline int32_t PlayAnimationResponse::_internal_number_of_frames_queued() const {
  return _impl_.number_of_frames_queued_;
}
inline int32_t PlayAnimationResponse::number_of_frames_queued() const {
  // @@protoc_insertion_point(field_get:server.PlayAnimationResponse.number_of_frames_queued)
  return _internal_number_of_frames_queued();
}
inline void PlayAnimationResponse::_internal_set_number_of_frames_queued(int32_t value) {
  
  _impl_.number_of_frames_queued_ = value;
}
inline void PlayAnimationResponse::set_number_of_frames_queued(int32_t value) {
  _internal_set_number_of_frames_queued(value);
  // @@protoc_insertion_point(field_set:server.PlayAnimationResponse.number_of_frames_queued)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace server

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::server::Creature_MotorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server::Creature_MotorType>() {
  return ::server::Creature_MotorType_descriptor();
}
template <> struct is_proto_enum< ::server::LogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server::LogLevel>() {
  return ::server::LogLevel_descriptor();
}
template <> struct is_proto_enum< ::server::SortBy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server::SortBy>() {
  return ::server::SortBy_descriptor();
}
template <> struct is_proto_enum< ::server::CreatureType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server::CreatureType>() {
  return ::server::CreatureType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_server_2eproto
