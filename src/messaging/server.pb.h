// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_server_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_server_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_server_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_server_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_server_2eproto;
namespace server {
class Creature;
struct CreatureDefaultTypeInternal;
extern CreatureDefaultTypeInternal _Creature_default_instance_;
class CreatureFilter;
struct CreatureFilterDefaultTypeInternal;
extern CreatureFilterDefaultTypeInternal _CreatureFilter_default_instance_;
class CreatureId;
struct CreatureIdDefaultTypeInternal;
extern CreatureIdDefaultTypeInternal _CreatureId_default_instance_;
class CreatureIdentifier;
struct CreatureIdentifierDefaultTypeInternal;
extern CreatureIdentifierDefaultTypeInternal _CreatureIdentifier_default_instance_;
class CreatureName;
struct CreatureNameDefaultTypeInternal;
extern CreatureNameDefaultTypeInternal _CreatureName_default_instance_;
class Creature_Motor;
struct Creature_MotorDefaultTypeInternal;
extern Creature_MotorDefaultTypeInternal _Creature_Motor_default_instance_;
class DatabaseInfo;
struct DatabaseInfoDefaultTypeInternal;
extern DatabaseInfoDefaultTypeInternal _DatabaseInfo_default_instance_;
class Frame;
struct FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class FrameResponse;
struct FrameResponseDefaultTypeInternal;
extern FrameResponseDefaultTypeInternal _FrameResponse_default_instance_;
class GetAllCreaturesResponse;
struct GetAllCreaturesResponseDefaultTypeInternal;
extern GetAllCreaturesResponseDefaultTypeInternal _GetAllCreaturesResponse_default_instance_;
class ListCreaturesResponse;
struct ListCreaturesResponseDefaultTypeInternal;
extern ListCreaturesResponseDefaultTypeInternal _ListCreaturesResponse_default_instance_;
class LogFilter;
struct LogFilterDefaultTypeInternal;
extern LogFilterDefaultTypeInternal _LogFilter_default_instance_;
class LogLine;
struct LogLineDefaultTypeInternal;
extern LogLineDefaultTypeInternal _LogLine_default_instance_;
class ServerStatus;
struct ServerStatusDefaultTypeInternal;
extern ServerStatusDefaultTypeInternal _ServerStatus_default_instance_;
}  // namespace server
PROTOBUF_NAMESPACE_OPEN
template<> ::server::Creature* Arena::CreateMaybeMessage<::server::Creature>(Arena*);
template<> ::server::CreatureFilter* Arena::CreateMaybeMessage<::server::CreatureFilter>(Arena*);
template<> ::server::CreatureId* Arena::CreateMaybeMessage<::server::CreatureId>(Arena*);
template<> ::server::CreatureIdentifier* Arena::CreateMaybeMessage<::server::CreatureIdentifier>(Arena*);
template<> ::server::CreatureName* Arena::CreateMaybeMessage<::server::CreatureName>(Arena*);
template<> ::server::Creature_Motor* Arena::CreateMaybeMessage<::server::Creature_Motor>(Arena*);
template<> ::server::DatabaseInfo* Arena::CreateMaybeMessage<::server::DatabaseInfo>(Arena*);
template<> ::server::Frame* Arena::CreateMaybeMessage<::server::Frame>(Arena*);
template<> ::server::FrameResponse* Arena::CreateMaybeMessage<::server::FrameResponse>(Arena*);
template<> ::server::GetAllCreaturesResponse* Arena::CreateMaybeMessage<::server::GetAllCreaturesResponse>(Arena*);
template<> ::server::ListCreaturesResponse* Arena::CreateMaybeMessage<::server::ListCreaturesResponse>(Arena*);
template<> ::server::LogFilter* Arena::CreateMaybeMessage<::server::LogFilter>(Arena*);
template<> ::server::LogLine* Arena::CreateMaybeMessage<::server::LogLine>(Arena*);
template<> ::server::ServerStatus* Arena::CreateMaybeMessage<::server::ServerStatus>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace server {

enum Creature_MotorType : int {
  Creature_MotorType_servo = 0,
  Creature_MotorType_stepper = 1,
  Creature_MotorType_Creature_MotorType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Creature_MotorType_Creature_MotorType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Creature_MotorType_IsValid(int value);
constexpr Creature_MotorType Creature_MotorType_MotorType_MIN = Creature_MotorType_servo;
constexpr Creature_MotorType Creature_MotorType_MotorType_MAX = Creature_MotorType_stepper;
constexpr int Creature_MotorType_MotorType_ARRAYSIZE = Creature_MotorType_MotorType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Creature_MotorType_descriptor();
template<typename T>
inline const std::string& Creature_MotorType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Creature_MotorType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Creature_MotorType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Creature_MotorType_descriptor(), enum_t_value);
}
inline bool Creature_MotorType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Creature_MotorType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Creature_MotorType>(
    Creature_MotorType_descriptor(), name, value);
}
enum LogLevel : int {
  trace = 0,
  debug = 1,
  info = 2,
  warn = 3,
  error = 4,
  critical = 5,
  fatal = 6,
  LogLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LogLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LogLevel_IsValid(int value);
constexpr LogLevel LogLevel_MIN = trace;
constexpr LogLevel LogLevel_MAX = fatal;
constexpr int LogLevel_ARRAYSIZE = LogLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogLevel_descriptor();
template<typename T>
inline const std::string& LogLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogLevel_descriptor(), enum_t_value);
}
inline bool LogLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogLevel>(
    LogLevel_descriptor(), name, value);
}
enum SortBy : int {
  name = 0,
  number = 1,
  SortBy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SortBy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SortBy_IsValid(int value);
constexpr SortBy SortBy_MIN = name;
constexpr SortBy SortBy_MAX = number;
constexpr int SortBy_ARRAYSIZE = SortBy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SortBy_descriptor();
template<typename T>
inline const std::string& SortBy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SortBy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SortBy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SortBy_descriptor(), enum_t_value);
}
inline bool SortBy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SortBy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SortBy>(
    SortBy_descriptor(), name, value);
}
// ===================================================================

class CreatureIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.CreatureIdentifier) */ {
 public:
  inline CreatureIdentifier() : CreatureIdentifier(nullptr) {}
  ~CreatureIdentifier() override;
  explicit PROTOBUF_CONSTEXPR CreatureIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatureIdentifier(const CreatureIdentifier& from);
  CreatureIdentifier(CreatureIdentifier&& from) noexcept
    : CreatureIdentifier() {
    *this = ::std::move(from);
  }

  inline CreatureIdentifier& operator=(const CreatureIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatureIdentifier& operator=(CreatureIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatureIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatureIdentifier* internal_default_instance() {
    return reinterpret_cast<const CreatureIdentifier*>(
               &_CreatureIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreatureIdentifier& a, CreatureIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatureIdentifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatureIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatureIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatureIdentifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatureIdentifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreatureIdentifier& from) {
    CreatureIdentifier::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatureIdentifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.CreatureIdentifier";
  }
  protected:
  explicit CreatureIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // bytes _id = 1;
  void clear__id();
  const std::string& _id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__id(ArgT0&& arg0, ArgT... args);
  std::string* mutable__id();
  PROTOBUF_NODISCARD std::string* release__id();
  void set_allocated__id(std::string* _id);
  private:
  const std::string& _internal__id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__id(const std::string& value);
  std::string* _internal_mutable__id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:server.CreatureIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class ListCreaturesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.ListCreaturesResponse) */ {
 public:
  inline ListCreaturesResponse() : ListCreaturesResponse(nullptr) {}
  ~ListCreaturesResponse() override;
  explicit PROTOBUF_CONSTEXPR ListCreaturesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListCreaturesResponse(const ListCreaturesResponse& from);
  ListCreaturesResponse(ListCreaturesResponse&& from) noexcept
    : ListCreaturesResponse() {
    *this = ::std::move(from);
  }

  inline ListCreaturesResponse& operator=(const ListCreaturesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListCreaturesResponse& operator=(ListCreaturesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListCreaturesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListCreaturesResponse* internal_default_instance() {
    return reinterpret_cast<const ListCreaturesResponse*>(
               &_ListCreaturesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListCreaturesResponse& a, ListCreaturesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListCreaturesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListCreaturesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListCreaturesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListCreaturesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListCreaturesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListCreaturesResponse& from) {
    ListCreaturesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListCreaturesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.ListCreaturesResponse";
  }
  protected:
  explicit ListCreaturesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreaturesIdsFieldNumber = 1,
  };
  // repeated .server.CreatureIdentifier creaturesIds = 1;
  int creaturesids_size() const;
  private:
  int _internal_creaturesids_size() const;
  public:
  void clear_creaturesids();
  ::server::CreatureIdentifier* mutable_creaturesids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::CreatureIdentifier >*
      mutable_creaturesids();
  private:
  const ::server::CreatureIdentifier& _internal_creaturesids(int index) const;
  ::server::CreatureIdentifier* _internal_add_creaturesids();
  public:
  const ::server::CreatureIdentifier& creaturesids(int index) const;
  ::server::CreatureIdentifier* add_creaturesids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::CreatureIdentifier >&
      creaturesids() const;

  // @@protoc_insertion_point(class_scope:server.ListCreaturesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::CreatureIdentifier > creaturesids_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class GetAllCreaturesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.GetAllCreaturesResponse) */ {
 public:
  inline GetAllCreaturesResponse() : GetAllCreaturesResponse(nullptr) {}
  ~GetAllCreaturesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetAllCreaturesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAllCreaturesResponse(const GetAllCreaturesResponse& from);
  GetAllCreaturesResponse(GetAllCreaturesResponse&& from) noexcept
    : GetAllCreaturesResponse() {
    *this = ::std::move(from);
  }

  inline GetAllCreaturesResponse& operator=(const GetAllCreaturesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAllCreaturesResponse& operator=(GetAllCreaturesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAllCreaturesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAllCreaturesResponse* internal_default_instance() {
    return reinterpret_cast<const GetAllCreaturesResponse*>(
               &_GetAllCreaturesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetAllCreaturesResponse& a, GetAllCreaturesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAllCreaturesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAllCreaturesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAllCreaturesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAllCreaturesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAllCreaturesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetAllCreaturesResponse& from) {
    GetAllCreaturesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAllCreaturesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.GetAllCreaturesResponse";
  }
  protected:
  explicit GetAllCreaturesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreaturesFieldNumber = 1,
  };
  // repeated .server.Creature creatures = 1;
  int creatures_size() const;
  private:
  int _internal_creatures_size() const;
  public:
  void clear_creatures();
  ::server::Creature* mutable_creatures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature >*
      mutable_creatures();
  private:
  const ::server::Creature& _internal_creatures(int index) const;
  ::server::Creature* _internal_add_creatures();
  public:
  const ::server::Creature& creatures(int index) const;
  ::server::Creature* add_creatures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature >&
      creatures() const;

  // @@protoc_insertion_point(class_scope:server.GetAllCreaturesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature > creatures_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class CreatureFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.CreatureFilter) */ {
 public:
  inline CreatureFilter() : CreatureFilter(nullptr) {}
  ~CreatureFilter() override;
  explicit PROTOBUF_CONSTEXPR CreatureFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatureFilter(const CreatureFilter& from);
  CreatureFilter(CreatureFilter&& from) noexcept
    : CreatureFilter() {
    *this = ::std::move(from);
  }

  inline CreatureFilter& operator=(const CreatureFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatureFilter& operator=(CreatureFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatureFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatureFilter* internal_default_instance() {
    return reinterpret_cast<const CreatureFilter*>(
               &_CreatureFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreatureFilter& a, CreatureFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatureFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatureFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatureFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatureFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatureFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreatureFilter& from) {
    CreatureFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatureFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.CreatureFilter";
  }
  protected:
  explicit CreatureFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
    kSortByFieldNumber = 2,
  };
  // string filter = 1;
  void clear_filter();
  const std::string& filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter();
  PROTOBUF_NODISCARD std::string* release_filter();
  void set_allocated_filter(std::string* filter);
  private:
  const std::string& _internal_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter(const std::string& value);
  std::string* _internal_mutable_filter();
  public:

  // .server.SortBy sortBy = 2;
  void clear_sortby();
  ::server::SortBy sortby() const;
  void set_sortby(::server::SortBy value);
  private:
  ::server::SortBy _internal_sortby() const;
  void _internal_set_sortby(::server::SortBy value);
  public:

  // @@protoc_insertion_point(class_scope:server.CreatureFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_;
    int sortby_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class DatabaseInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.DatabaseInfo) */ {
 public:
  inline DatabaseInfo() : DatabaseInfo(nullptr) {}
  ~DatabaseInfo() override;
  explicit PROTOBUF_CONSTEXPR DatabaseInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DatabaseInfo(const DatabaseInfo& from);
  DatabaseInfo(DatabaseInfo&& from) noexcept
    : DatabaseInfo() {
    *this = ::std::move(from);
  }

  inline DatabaseInfo& operator=(const DatabaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DatabaseInfo& operator=(DatabaseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DatabaseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DatabaseInfo* internal_default_instance() {
    return reinterpret_cast<const DatabaseInfo*>(
               &_DatabaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DatabaseInfo& a, DatabaseInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DatabaseInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DatabaseInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DatabaseInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DatabaseInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DatabaseInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DatabaseInfo& from) {
    DatabaseInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatabaseInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.DatabaseInfo";
  }
  protected:
  explicit DatabaseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kHelpFieldNumber = 2,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string help = 2;
  void clear_help();
  const std::string& help() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_help(ArgT0&& arg0, ArgT... args);
  std::string* mutable_help();
  PROTOBUF_NODISCARD std::string* release_help();
  void set_allocated_help(std::string* help);
  private:
  const std::string& _internal_help() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_help(const std::string& value);
  std::string* _internal_mutable_help();
  public:

  // @@protoc_insertion_point(class_scope:server.DatabaseInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr help_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class LogFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.LogFilter) */ {
 public:
  inline LogFilter() : LogFilter(nullptr) {}
  ~LogFilter() override;
  explicit PROTOBUF_CONSTEXPR LogFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogFilter(const LogFilter& from);
  LogFilter(LogFilter&& from) noexcept
    : LogFilter() {
    *this = ::std::move(from);
  }

  inline LogFilter& operator=(const LogFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogFilter& operator=(LogFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogFilter* internal_default_instance() {
    return reinterpret_cast<const LogFilter*>(
               &_LogFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LogFilter& a, LogFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(LogFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogFilter& from) {
    LogFilter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.LogFilter";
  }
  protected:
  explicit LogFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
  };
  // .server.LogLevel level = 1;
  void clear_level();
  ::server::LogLevel level() const;
  void set_level(::server::LogLevel value);
  private:
  ::server::LogLevel _internal_level() const;
  void _internal_set_level(::server::LogLevel value);
  public:

  // @@protoc_insertion_point(class_scope:server.LogFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class CreatureId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.CreatureId) */ {
 public:
  inline CreatureId() : CreatureId(nullptr) {}
  ~CreatureId() override;
  explicit PROTOBUF_CONSTEXPR CreatureId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatureId(const CreatureId& from);
  CreatureId(CreatureId&& from) noexcept
    : CreatureId() {
    *this = ::std::move(from);
  }

  inline CreatureId& operator=(const CreatureId& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatureId& operator=(CreatureId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatureId& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatureId* internal_default_instance() {
    return reinterpret_cast<const CreatureId*>(
               &_CreatureId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CreatureId& a, CreatureId& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatureId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatureId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatureId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatureId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatureId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreatureId& from) {
    CreatureId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatureId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.CreatureId";
  }
  protected:
  explicit CreatureId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes _id = 1;
  void clear__id();
  const std::string& _id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__id(ArgT0&& arg0, ArgT... args);
  std::string* mutable__id();
  PROTOBUF_NODISCARD std::string* release__id();
  void set_allocated__id(std::string* _id);
  private:
  const std::string& _internal__id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__id(const std::string& value);
  std::string* _internal_mutable__id();
  public:

  // @@protoc_insertion_point(class_scope:server.CreatureId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class CreatureName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.CreatureName) */ {
 public:
  inline CreatureName() : CreatureName(nullptr) {}
  ~CreatureName() override;
  explicit PROTOBUF_CONSTEXPR CreatureName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatureName(const CreatureName& from);
  CreatureName(CreatureName&& from) noexcept
    : CreatureName() {
    *this = ::std::move(from);
  }

  inline CreatureName& operator=(const CreatureName& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatureName& operator=(CreatureName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatureName& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatureName* internal_default_instance() {
    return reinterpret_cast<const CreatureName*>(
               &_CreatureName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CreatureName& a, CreatureName& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatureName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatureName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatureName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatureName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatureName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreatureName& from) {
    CreatureName::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatureName* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.CreatureName";
  }
  protected:
  explicit CreatureName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:server.CreatureName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class Creature_Motor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.Creature.Motor) */ {
 public:
  inline Creature_Motor() : Creature_Motor(nullptr) {}
  ~Creature_Motor() override;
  explicit PROTOBUF_CONSTEXPR Creature_Motor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Creature_Motor(const Creature_Motor& from);
  Creature_Motor(Creature_Motor&& from) noexcept
    : Creature_Motor() {
    *this = ::std::move(from);
  }

  inline Creature_Motor& operator=(const Creature_Motor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Creature_Motor& operator=(Creature_Motor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Creature_Motor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Creature_Motor* internal_default_instance() {
    return reinterpret_cast<const Creature_Motor*>(
               &_Creature_Motor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Creature_Motor& a, Creature_Motor& b) {
    a.Swap(&b);
  }
  inline void Swap(Creature_Motor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Creature_Motor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Creature_Motor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Creature_Motor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Creature_Motor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Creature_Motor& from) {
    Creature_Motor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Creature_Motor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.Creature.Motor";
  }
  protected:
  explicit Creature_Motor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
    kNumberFieldNumber = 4,
    kMaxValueFieldNumber = 5,
    kMinValueFieldNumber = 6,
    kSmoothingValueFieldNumber = 7,
  };
  // bytes _id = 1;
  void clear__id();
  const std::string& _id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__id(ArgT0&& arg0, ArgT... args);
  std::string* mutable__id();
  PROTOBUF_NODISCARD std::string* release__id();
  void set_allocated__id(std::string* _id);
  private:
  const std::string& _internal__id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__id(const std::string& value);
  std::string* _internal_mutable__id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .server.Creature.MotorType type = 3;
  void clear_type();
  ::server::Creature_MotorType type() const;
  void set_type(::server::Creature_MotorType value);
  private:
  ::server::Creature_MotorType _internal_type() const;
  void _internal_set_type(::server::Creature_MotorType value);
  public:

  // uint32 number = 4;
  void clear_number();
  uint32_t number() const;
  void set_number(uint32_t value);
  private:
  uint32_t _internal_number() const;
  void _internal_set_number(uint32_t value);
  public:

  // uint32 max_value = 5;
  void clear_max_value();
  uint32_t max_value() const;
  void set_max_value(uint32_t value);
  private:
  uint32_t _internal_max_value() const;
  void _internal_set_max_value(uint32_t value);
  public:

  // uint32 min_value = 6;
  void clear_min_value();
  uint32_t min_value() const;
  void set_min_value(uint32_t value);
  private:
  uint32_t _internal_min_value() const;
  void _internal_set_min_value(uint32_t value);
  public:

  // double smoothing_value = 7;
  void clear_smoothing_value();
  double smoothing_value() const;
  void set_smoothing_value(double value);
  private:
  double _internal_smoothing_value() const;
  void _internal_set_smoothing_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:server.Creature.Motor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int type_;
    uint32_t number_;
    uint32_t max_value_;
    uint32_t min_value_;
    double smoothing_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class Creature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.Creature) */ {
 public:
  inline Creature() : Creature(nullptr) {}
  ~Creature() override;
  explicit PROTOBUF_CONSTEXPR Creature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Creature(const Creature& from);
  Creature(Creature&& from) noexcept
    : Creature() {
    *this = ::std::move(from);
  }

  inline Creature& operator=(const Creature& from) {
    CopyFrom(from);
    return *this;
  }
  inline Creature& operator=(Creature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Creature& default_instance() {
    return *internal_default_instance();
  }
  static inline const Creature* internal_default_instance() {
    return reinterpret_cast<const Creature*>(
               &_Creature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Creature& a, Creature& b) {
    a.Swap(&b);
  }
  inline void Swap(Creature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Creature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Creature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Creature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Creature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Creature& from) {
    Creature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Creature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.Creature";
  }
  protected:
  explicit Creature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Creature_Motor Motor;

  typedef Creature_MotorType MotorType;
  static constexpr MotorType servo =
    Creature_MotorType_servo;
  static constexpr MotorType stepper =
    Creature_MotorType_stepper;
  static inline bool MotorType_IsValid(int value) {
    return Creature_MotorType_IsValid(value);
  }
  static constexpr MotorType MotorType_MIN =
    Creature_MotorType_MotorType_MIN;
  static constexpr MotorType MotorType_MAX =
    Creature_MotorType_MotorType_MAX;
  static constexpr int MotorType_ARRAYSIZE =
    Creature_MotorType_MotorType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MotorType_descriptor() {
    return Creature_MotorType_descriptor();
  }
  template<typename T>
  static inline const std::string& MotorType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MotorType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MotorType_Name.");
    return Creature_MotorType_Name(enum_t_value);
  }
  static inline bool MotorType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MotorType* value) {
    return Creature_MotorType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMotorsFieldNumber = 8,
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kSacnIpFieldNumber = 4,
    kLastUpdatedFieldNumber = 3,
    kUniverseFieldNumber = 5,
    kDmxBaseFieldNumber = 6,
    kNumberOfMotorsFieldNumber = 7,
  };
  // repeated .server.Creature.Motor motors = 8;
  int motors_size() const;
  private:
  int _internal_motors_size() const;
  public:
  void clear_motors();
  ::server::Creature_Motor* mutable_motors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor >*
      mutable_motors();
  private:
  const ::server::Creature_Motor& _internal_motors(int index) const;
  ::server::Creature_Motor* _internal_add_motors();
  public:
  const ::server::Creature_Motor& motors(int index) const;
  ::server::Creature_Motor* add_motors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor >&
      motors() const;

  // bytes _id = 1;
  void clear__id();
  const std::string& _id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__id(ArgT0&& arg0, ArgT... args);
  std::string* mutable__id();
  PROTOBUF_NODISCARD std::string* release__id();
  void set_allocated__id(std::string* _id);
  private:
  const std::string& _internal__id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__id(const std::string& value);
  std::string* _internal_mutable__id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string sacn_ip = 4;
  void clear_sacn_ip();
  const std::string& sacn_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sacn_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sacn_ip();
  PROTOBUF_NODISCARD std::string* release_sacn_ip();
  void set_allocated_sacn_ip(std::string* sacn_ip);
  private:
  const std::string& _internal_sacn_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sacn_ip(const std::string& value);
  std::string* _internal_mutable_sacn_ip();
  public:

  // .google.protobuf.Timestamp last_updated = 3;
  bool has_last_updated() const;
  private:
  bool _internal_has_last_updated() const;
  public:
  void clear_last_updated();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_updated() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_updated();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_updated();
  void set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_updated() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_updated();
  public:
  void unsafe_arena_set_allocated_last_updated(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_updated();

  // uint32 universe = 5;
  void clear_universe();
  uint32_t universe() const;
  void set_universe(uint32_t value);
  private:
  uint32_t _internal_universe() const;
  void _internal_set_universe(uint32_t value);
  public:

  // uint32 dmx_base = 6;
  void clear_dmx_base();
  uint32_t dmx_base() const;
  void set_dmx_base(uint32_t value);
  private:
  uint32_t _internal_dmx_base() const;
  void _internal_set_dmx_base(uint32_t value);
  public:

  // uint32 number_of_motors = 7;
  void clear_number_of_motors();
  uint32_t number_of_motors() const;
  void set_number_of_motors(uint32_t value);
  private:
  uint32_t _internal_number_of_motors() const;
  void _internal_set_number_of_motors(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:server.Creature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor > motors_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sacn_ip_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated_;
    uint32_t universe_;
    uint32_t dmx_base_;
    uint32_t number_of_motors_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class LogLine final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.LogLine) */ {
 public:
  inline LogLine() : LogLine(nullptr) {}
  ~LogLine() override;
  explicit PROTOBUF_CONSTEXPR LogLine(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogLine(const LogLine& from);
  LogLine(LogLine&& from) noexcept
    : LogLine() {
    *this = ::std::move(from);
  }

  inline LogLine& operator=(const LogLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogLine& operator=(LogLine&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogLine& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogLine* internal_default_instance() {
    return reinterpret_cast<const LogLine*>(
               &_LogLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LogLine& a, LogLine& b) {
    a.Swap(&b);
  }
  inline void Swap(LogLine* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogLine>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogLine& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogLine& from) {
    LogLine::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogLine* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.LogLine";
  }
  protected:
  explicit LogLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kLevelFieldNumber = 1,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .google.protobuf.Timestamp timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .server.LogLevel level = 1;
  void clear_level();
  ::server::LogLevel level() const;
  void set_level(::server::LogLevel value);
  private:
  ::server::LogLevel _internal_level() const;
  void _internal_set_level(::server::LogLevel value);
  public:

  // @@protoc_insertion_point(class_scope:server.LogLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
    int level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class Frame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.Frame) */ {
 public:
  inline Frame() : Frame(nullptr) {}
  ~Frame() override;
  explicit PROTOBUF_CONSTEXPR Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Frame(const Frame& from);
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Frame& default_instance() {
    return *internal_default_instance();
  }
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Frame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Frame& from) {
    Frame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.Frame";
  }
  protected:
  explicit Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatureNameFieldNumber = 3,
    kSacnIpFieldNumber = 4,
    kFrameFieldNumber = 10,
    kUniverseFieldNumber = 1,
    kDmxOffsetFieldNumber = 2,
  };
  // string creature_name = 3;
  void clear_creature_name();
  const std::string& creature_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creature_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creature_name();
  PROTOBUF_NODISCARD std::string* release_creature_name();
  void set_allocated_creature_name(std::string* creature_name);
  private:
  const std::string& _internal_creature_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creature_name(const std::string& value);
  std::string* _internal_mutable_creature_name();
  public:

  // string sacn_ip = 4;
  void clear_sacn_ip();
  const std::string& sacn_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sacn_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sacn_ip();
  PROTOBUF_NODISCARD std::string* release_sacn_ip();
  void set_allocated_sacn_ip(std::string* sacn_ip);
  private:
  const std::string& _internal_sacn_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sacn_ip(const std::string& value);
  std::string* _internal_mutable_sacn_ip();
  public:

  // bytes frame = 10;
  void clear_frame();
  const std::string& frame() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame();
  PROTOBUF_NODISCARD std::string* release_frame();
  void set_allocated_frame(std::string* frame);
  private:
  const std::string& _internal_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame(const std::string& value);
  std::string* _internal_mutable_frame();
  public:

  // uint32 universe = 1;
  void clear_universe();
  uint32_t universe() const;
  void set_universe(uint32_t value);
  private:
  uint32_t _internal_universe() const;
  void _internal_set_universe(uint32_t value);
  public:

  // uint32 dmx_offset = 2;
  void clear_dmx_offset();
  uint32_t dmx_offset() const;
  void set_dmx_offset(uint32_t value);
  private:
  uint32_t _internal_dmx_offset() const;
  void _internal_set_dmx_offset(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:server.Frame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creature_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sacn_ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_;
    uint32_t universe_;
    uint32_t dmx_offset_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class FrameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.FrameResponse) */ {
 public:
  inline FrameResponse() : FrameResponse(nullptr) {}
  ~FrameResponse() override;
  explicit PROTOBUF_CONSTEXPR FrameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrameResponse(const FrameResponse& from);
  FrameResponse(FrameResponse&& from) noexcept
    : FrameResponse() {
    *this = ::std::move(from);
  }

  inline FrameResponse& operator=(const FrameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrameResponse& operator=(FrameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrameResponse* internal_default_instance() {
    return reinterpret_cast<const FrameResponse*>(
               &_FrameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FrameResponse& a, FrameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FrameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrameResponse& from) {
    FrameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.FrameResponse";
  }
  protected:
  explicit FrameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kFramesProcessedFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // uint32 frames_processed = 1;
  void clear_frames_processed();
  uint32_t frames_processed() const;
  void set_frames_processed(uint32_t value);
  private:
  uint32_t _internal_frames_processed() const;
  void _internal_set_frames_processed(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:server.FrameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    uint32_t frames_processed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// -------------------------------------------------------------------

class ServerStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:server.ServerStatus) */ {
 public:
  inline ServerStatus() : ServerStatus(nullptr) {}
  ~ServerStatus() override;
  explicit PROTOBUF_CONSTEXPR ServerStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServerStatus(const ServerStatus& from);
  ServerStatus(ServerStatus&& from) noexcept
    : ServerStatus() {
    *this = ::std::move(from);
  }

  inline ServerStatus& operator=(const ServerStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerStatus& operator=(ServerStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServerStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerStatus* internal_default_instance() {
    return reinterpret_cast<const ServerStatus*>(
               &_ServerStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ServerStatus& a, ServerStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServerStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServerStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ServerStatus& from) {
    ServerStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "server.ServerStatus";
  }
  protected:
  explicit ServerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartedAtFieldNumber = 2,
    kFramesProcessedFieldNumber = 1,
  };
  // .google.protobuf.Timestamp started_at = 2;
  bool has_started_at() const;
  private:
  bool _internal_has_started_at() const;
  public:
  void clear_started_at();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& started_at() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_started_at();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_started_at();
  void set_allocated_started_at(::PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_started_at() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_started_at();
  public:
  void unsafe_arena_set_allocated_started_at(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_started_at();

  // uint64 frames_processed = 1;
  void clear_frames_processed();
  uint64_t frames_processed() const;
  void set_frames_processed(uint64_t value);
  private:
  uint64_t _internal_frames_processed() const;
  void _internal_set_frames_processed(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:server.ServerStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at_;
    uint64_t frames_processed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_server_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreatureIdentifier

// bytes _id = 1;
inline void CreatureIdentifier::clear__id() {
  _impl_._id_.ClearToEmpty();
}
inline const std::string& CreatureIdentifier::_id() const {
  // @@protoc_insertion_point(field_get:server.CreatureIdentifier._id)
  return _internal__id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatureIdentifier::set__id(ArgT0&& arg0, ArgT... args) {
 
 _impl_._id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.CreatureIdentifier._id)
}
inline std::string* CreatureIdentifier::mutable__id() {
  std::string* _s = _internal_mutable__id();
  // @@protoc_insertion_point(field_mutable:server.CreatureIdentifier._id)
  return _s;
}
inline const std::string& CreatureIdentifier::_internal__id() const {
  return _impl_._id_.Get();
}
inline void CreatureIdentifier::_internal_set__id(const std::string& value) {
  
  _impl_._id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreatureIdentifier::_internal_mutable__id() {
  
  return _impl_._id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreatureIdentifier::release__id() {
  // @@protoc_insertion_point(field_release:server.CreatureIdentifier._id)
  return _impl_._id_.Release();
}
inline void CreatureIdentifier::set_allocated__id(std::string* _id) {
  if (_id != nullptr) {
    
  } else {
    
  }
  _impl_._id_.SetAllocated(_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._id_.IsDefault()) {
    _impl_._id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.CreatureIdentifier._id)
}

// string name = 2;
inline void CreatureIdentifier::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreatureIdentifier::name() const {
  // @@protoc_insertion_point(field_get:server.CreatureIdentifier.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatureIdentifier::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.CreatureIdentifier.name)
}
inline std::string* CreatureIdentifier::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:server.CreatureIdentifier.name)
  return _s;
}
inline const std::string& CreatureIdentifier::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreatureIdentifier::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreatureIdentifier::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreatureIdentifier::release_name() {
  // @@protoc_insertion_point(field_release:server.CreatureIdentifier.name)
  return _impl_.name_.Release();
}
inline void CreatureIdentifier::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.CreatureIdentifier.name)
}

// -------------------------------------------------------------------

// ListCreaturesResponse

// repeated .server.CreatureIdentifier creaturesIds = 1;
inline int ListCreaturesResponse::_internal_creaturesids_size() const {
  return _impl_.creaturesids_.size();
}
inline int ListCreaturesResponse::creaturesids_size() const {
  return _internal_creaturesids_size();
}
inline void ListCreaturesResponse::clear_creaturesids() {
  _impl_.creaturesids_.Clear();
}
inline ::server::CreatureIdentifier* ListCreaturesResponse::mutable_creaturesids(int index) {
  // @@protoc_insertion_point(field_mutable:server.ListCreaturesResponse.creaturesIds)
  return _impl_.creaturesids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::CreatureIdentifier >*
ListCreaturesResponse::mutable_creaturesids() {
  // @@protoc_insertion_point(field_mutable_list:server.ListCreaturesResponse.creaturesIds)
  return &_impl_.creaturesids_;
}
inline const ::server::CreatureIdentifier& ListCreaturesResponse::_internal_creaturesids(int index) const {
  return _impl_.creaturesids_.Get(index);
}
inline const ::server::CreatureIdentifier& ListCreaturesResponse::creaturesids(int index) const {
  // @@protoc_insertion_point(field_get:server.ListCreaturesResponse.creaturesIds)
  return _internal_creaturesids(index);
}
inline ::server::CreatureIdentifier* ListCreaturesResponse::_internal_add_creaturesids() {
  return _impl_.creaturesids_.Add();
}
inline ::server::CreatureIdentifier* ListCreaturesResponse::add_creaturesids() {
  ::server::CreatureIdentifier* _add = _internal_add_creaturesids();
  // @@protoc_insertion_point(field_add:server.ListCreaturesResponse.creaturesIds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::CreatureIdentifier >&
ListCreaturesResponse::creaturesids() const {
  // @@protoc_insertion_point(field_list:server.ListCreaturesResponse.creaturesIds)
  return _impl_.creaturesids_;
}

// -------------------------------------------------------------------

// GetAllCreaturesResponse

// repeated .server.Creature creatures = 1;
inline int GetAllCreaturesResponse::_internal_creatures_size() const {
  return _impl_.creatures_.size();
}
inline int GetAllCreaturesResponse::creatures_size() const {
  return _internal_creatures_size();
}
inline void GetAllCreaturesResponse::clear_creatures() {
  _impl_.creatures_.Clear();
}
inline ::server::Creature* GetAllCreaturesResponse::mutable_creatures(int index) {
  // @@protoc_insertion_point(field_mutable:server.GetAllCreaturesResponse.creatures)
  return _impl_.creatures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature >*
GetAllCreaturesResponse::mutable_creatures() {
  // @@protoc_insertion_point(field_mutable_list:server.GetAllCreaturesResponse.creatures)
  return &_impl_.creatures_;
}
inline const ::server::Creature& GetAllCreaturesResponse::_internal_creatures(int index) const {
  return _impl_.creatures_.Get(index);
}
inline const ::server::Creature& GetAllCreaturesResponse::creatures(int index) const {
  // @@protoc_insertion_point(field_get:server.GetAllCreaturesResponse.creatures)
  return _internal_creatures(index);
}
inline ::server::Creature* GetAllCreaturesResponse::_internal_add_creatures() {
  return _impl_.creatures_.Add();
}
inline ::server::Creature* GetAllCreaturesResponse::add_creatures() {
  ::server::Creature* _add = _internal_add_creatures();
  // @@protoc_insertion_point(field_add:server.GetAllCreaturesResponse.creatures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature >&
GetAllCreaturesResponse::creatures() const {
  // @@protoc_insertion_point(field_list:server.GetAllCreaturesResponse.creatures)
  return _impl_.creatures_;
}

// -------------------------------------------------------------------

// CreatureFilter

// string filter = 1;
inline void CreatureFilter::clear_filter() {
  _impl_.filter_.ClearToEmpty();
}
inline const std::string& CreatureFilter::filter() const {
  // @@protoc_insertion_point(field_get:server.CreatureFilter.filter)
  return _internal_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatureFilter::set_filter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.CreatureFilter.filter)
}
inline std::string* CreatureFilter::mutable_filter() {
  std::string* _s = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:server.CreatureFilter.filter)
  return _s;
}
inline const std::string& CreatureFilter::_internal_filter() const {
  return _impl_.filter_.Get();
}
inline void CreatureFilter::_internal_set_filter(const std::string& value) {
  
  _impl_.filter_.Set(value, GetArenaForAllocation());
}
inline std::string* CreatureFilter::_internal_mutable_filter() {
  
  return _impl_.filter_.Mutable(GetArenaForAllocation());
}
inline std::string* CreatureFilter::release_filter() {
  // @@protoc_insertion_point(field_release:server.CreatureFilter.filter)
  return _impl_.filter_.Release();
}
inline void CreatureFilter::set_allocated_filter(std::string* filter) {
  if (filter != nullptr) {
    
  } else {
    
  }
  _impl_.filter_.SetAllocated(filter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filter_.IsDefault()) {
    _impl_.filter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.CreatureFilter.filter)
}

// .server.SortBy sortBy = 2;
inline void CreatureFilter::clear_sortby() {
  _impl_.sortby_ = 0;
}
inline ::server::SortBy CreatureFilter::_internal_sortby() const {
  return static_cast< ::server::SortBy >(_impl_.sortby_);
}
inline ::server::SortBy CreatureFilter::sortby() const {
  // @@protoc_insertion_point(field_get:server.CreatureFilter.sortBy)
  return _internal_sortby();
}
inline void CreatureFilter::_internal_set_sortby(::server::SortBy value) {
  
  _impl_.sortby_ = value;
}
inline void CreatureFilter::set_sortby(::server::SortBy value) {
  _internal_set_sortby(value);
  // @@protoc_insertion_point(field_set:server.CreatureFilter.sortBy)
}

// -------------------------------------------------------------------

// DatabaseInfo

// string message = 1;
inline void DatabaseInfo::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& DatabaseInfo::message() const {
  // @@protoc_insertion_point(field_get:server.DatabaseInfo.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatabaseInfo::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.DatabaseInfo.message)
}
inline std::string* DatabaseInfo::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:server.DatabaseInfo.message)
  return _s;
}
inline const std::string& DatabaseInfo::_internal_message() const {
  return _impl_.message_.Get();
}
inline void DatabaseInfo::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* DatabaseInfo::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* DatabaseInfo::release_message() {
  // @@protoc_insertion_point(field_release:server.DatabaseInfo.message)
  return _impl_.message_.Release();
}
inline void DatabaseInfo::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.DatabaseInfo.message)
}

// string help = 2;
inline void DatabaseInfo::clear_help() {
  _impl_.help_.ClearToEmpty();
}
inline const std::string& DatabaseInfo::help() const {
  // @@protoc_insertion_point(field_get:server.DatabaseInfo.help)
  return _internal_help();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DatabaseInfo::set_help(ArgT0&& arg0, ArgT... args) {
 
 _impl_.help_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.DatabaseInfo.help)
}
inline std::string* DatabaseInfo::mutable_help() {
  std::string* _s = _internal_mutable_help();
  // @@protoc_insertion_point(field_mutable:server.DatabaseInfo.help)
  return _s;
}
inline const std::string& DatabaseInfo::_internal_help() const {
  return _impl_.help_.Get();
}
inline void DatabaseInfo::_internal_set_help(const std::string& value) {
  
  _impl_.help_.Set(value, GetArenaForAllocation());
}
inline std::string* DatabaseInfo::_internal_mutable_help() {
  
  return _impl_.help_.Mutable(GetArenaForAllocation());
}
inline std::string* DatabaseInfo::release_help() {
  // @@protoc_insertion_point(field_release:server.DatabaseInfo.help)
  return _impl_.help_.Release();
}
inline void DatabaseInfo::set_allocated_help(std::string* help) {
  if (help != nullptr) {
    
  } else {
    
  }
  _impl_.help_.SetAllocated(help, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.help_.IsDefault()) {
    _impl_.help_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.DatabaseInfo.help)
}

// -------------------------------------------------------------------

// LogFilter

// .server.LogLevel level = 1;
inline void LogFilter::clear_level() {
  _impl_.level_ = 0;
}
inline ::server::LogLevel LogFilter::_internal_level() const {
  return static_cast< ::server::LogLevel >(_impl_.level_);
}
inline ::server::LogLevel LogFilter::level() const {
  // @@protoc_insertion_point(field_get:server.LogFilter.level)
  return _internal_level();
}
inline void LogFilter::_internal_set_level(::server::LogLevel value) {
  
  _impl_.level_ = value;
}
inline void LogFilter::set_level(::server::LogLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:server.LogFilter.level)
}

// -------------------------------------------------------------------

// CreatureId

// bytes _id = 1;
inline void CreatureId::clear__id() {
  _impl_._id_.ClearToEmpty();
}
inline const std::string& CreatureId::_id() const {
  // @@protoc_insertion_point(field_get:server.CreatureId._id)
  return _internal__id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatureId::set__id(ArgT0&& arg0, ArgT... args) {
 
 _impl_._id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.CreatureId._id)
}
inline std::string* CreatureId::mutable__id() {
  std::string* _s = _internal_mutable__id();
  // @@protoc_insertion_point(field_mutable:server.CreatureId._id)
  return _s;
}
inline const std::string& CreatureId::_internal__id() const {
  return _impl_._id_.Get();
}
inline void CreatureId::_internal_set__id(const std::string& value) {
  
  _impl_._id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreatureId::_internal_mutable__id() {
  
  return _impl_._id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreatureId::release__id() {
  // @@protoc_insertion_point(field_release:server.CreatureId._id)
  return _impl_._id_.Release();
}
inline void CreatureId::set_allocated__id(std::string* _id) {
  if (_id != nullptr) {
    
  } else {
    
  }
  _impl_._id_.SetAllocated(_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._id_.IsDefault()) {
    _impl_._id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.CreatureId._id)
}

// -------------------------------------------------------------------

// CreatureName

// string name = 1;
inline void CreatureName::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& CreatureName::name() const {
  // @@protoc_insertion_point(field_get:server.CreatureName.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatureName::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.CreatureName.name)
}
inline std::string* CreatureName::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:server.CreatureName.name)
  return _s;
}
inline const std::string& CreatureName::_internal_name() const {
  return _impl_.name_.Get();
}
inline void CreatureName::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreatureName::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreatureName::release_name() {
  // @@protoc_insertion_point(field_release:server.CreatureName.name)
  return _impl_.name_.Release();
}
inline void CreatureName::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.CreatureName.name)
}

// -------------------------------------------------------------------

// Creature_Motor

// bytes _id = 1;
inline void Creature_Motor::clear__id() {
  _impl_._id_.ClearToEmpty();
}
inline const std::string& Creature_Motor::_id() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor._id)
  return _internal__id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Creature_Motor::set__id(ArgT0&& arg0, ArgT... args) {
 
 _impl_._id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Creature.Motor._id)
}
inline std::string* Creature_Motor::mutable__id() {
  std::string* _s = _internal_mutable__id();
  // @@protoc_insertion_point(field_mutable:server.Creature.Motor._id)
  return _s;
}
inline const std::string& Creature_Motor::_internal__id() const {
  return _impl_._id_.Get();
}
inline void Creature_Motor::_internal_set__id(const std::string& value) {
  
  _impl_._id_.Set(value, GetArenaForAllocation());
}
inline std::string* Creature_Motor::_internal_mutable__id() {
  
  return _impl_._id_.Mutable(GetArenaForAllocation());
}
inline std::string* Creature_Motor::release__id() {
  // @@protoc_insertion_point(field_release:server.Creature.Motor._id)
  return _impl_._id_.Release();
}
inline void Creature_Motor::set_allocated__id(std::string* _id) {
  if (_id != nullptr) {
    
  } else {
    
  }
  _impl_._id_.SetAllocated(_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._id_.IsDefault()) {
    _impl_._id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Creature.Motor._id)
}

// string name = 2;
inline void Creature_Motor::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Creature_Motor::name() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Creature_Motor::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Creature.Motor.name)
}
inline std::string* Creature_Motor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:server.Creature.Motor.name)
  return _s;
}
inline const std::string& Creature_Motor::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Creature_Motor::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Creature_Motor::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Creature_Motor::release_name() {
  // @@protoc_insertion_point(field_release:server.Creature.Motor.name)
  return _impl_.name_.Release();
}
inline void Creature_Motor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Creature.Motor.name)
}

// .server.Creature.MotorType type = 3;
inline void Creature_Motor::clear_type() {
  _impl_.type_ = 0;
}
inline ::server::Creature_MotorType Creature_Motor::_internal_type() const {
  return static_cast< ::server::Creature_MotorType >(_impl_.type_);
}
inline ::server::Creature_MotorType Creature_Motor::type() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.type)
  return _internal_type();
}
inline void Creature_Motor::_internal_set_type(::server::Creature_MotorType value) {
  
  _impl_.type_ = value;
}
inline void Creature_Motor::set_type(::server::Creature_MotorType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.type)
}

// uint32 number = 4;
inline void Creature_Motor::clear_number() {
  _impl_.number_ = 0u;
}
inline uint32_t Creature_Motor::_internal_number() const {
  return _impl_.number_;
}
inline uint32_t Creature_Motor::number() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.number)
  return _internal_number();
}
inline void Creature_Motor::_internal_set_number(uint32_t value) {
  
  _impl_.number_ = value;
}
inline void Creature_Motor::set_number(uint32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.number)
}

// uint32 max_value = 5;
inline void Creature_Motor::clear_max_value() {
  _impl_.max_value_ = 0u;
}
inline uint32_t Creature_Motor::_internal_max_value() const {
  return _impl_.max_value_;
}
inline uint32_t Creature_Motor::max_value() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.max_value)
  return _internal_max_value();
}
inline void Creature_Motor::_internal_set_max_value(uint32_t value) {
  
  _impl_.max_value_ = value;
}
inline void Creature_Motor::set_max_value(uint32_t value) {
  _internal_set_max_value(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.max_value)
}

// uint32 min_value = 6;
inline void Creature_Motor::clear_min_value() {
  _impl_.min_value_ = 0u;
}
inline uint32_t Creature_Motor::_internal_min_value() const {
  return _impl_.min_value_;
}
inline uint32_t Creature_Motor::min_value() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.min_value)
  return _internal_min_value();
}
inline void Creature_Motor::_internal_set_min_value(uint32_t value) {
  
  _impl_.min_value_ = value;
}
inline void Creature_Motor::set_min_value(uint32_t value) {
  _internal_set_min_value(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.min_value)
}

// double smoothing_value = 7;
inline void Creature_Motor::clear_smoothing_value() {
  _impl_.smoothing_value_ = 0;
}
inline double Creature_Motor::_internal_smoothing_value() const {
  return _impl_.smoothing_value_;
}
inline double Creature_Motor::smoothing_value() const {
  // @@protoc_insertion_point(field_get:server.Creature.Motor.smoothing_value)
  return _internal_smoothing_value();
}
inline void Creature_Motor::_internal_set_smoothing_value(double value) {
  
  _impl_.smoothing_value_ = value;
}
inline void Creature_Motor::set_smoothing_value(double value) {
  _internal_set_smoothing_value(value);
  // @@protoc_insertion_point(field_set:server.Creature.Motor.smoothing_value)
}

// -------------------------------------------------------------------

// Creature

// bytes _id = 1;
inline void Creature::clear__id() {
  _impl_._id_.ClearToEmpty();
}
inline const std::string& Creature::_id() const {
  // @@protoc_insertion_point(field_get:server.Creature._id)
  return _internal__id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Creature::set__id(ArgT0&& arg0, ArgT... args) {
 
 _impl_._id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Creature._id)
}
inline std::string* Creature::mutable__id() {
  std::string* _s = _internal_mutable__id();
  // @@protoc_insertion_point(field_mutable:server.Creature._id)
  return _s;
}
inline const std::string& Creature::_internal__id() const {
  return _impl_._id_.Get();
}
inline void Creature::_internal_set__id(const std::string& value) {
  
  _impl_._id_.Set(value, GetArenaForAllocation());
}
inline std::string* Creature::_internal_mutable__id() {
  
  return _impl_._id_.Mutable(GetArenaForAllocation());
}
inline std::string* Creature::release__id() {
  // @@protoc_insertion_point(field_release:server.Creature._id)
  return _impl_._id_.Release();
}
inline void Creature::set_allocated__id(std::string* _id) {
  if (_id != nullptr) {
    
  } else {
    
  }
  _impl_._id_.SetAllocated(_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_._id_.IsDefault()) {
    _impl_._id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Creature._id)
}

// string name = 2;
inline void Creature::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Creature::name() const {
  // @@protoc_insertion_point(field_get:server.Creature.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Creature::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Creature.name)
}
inline std::string* Creature::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:server.Creature.name)
  return _s;
}
inline const std::string& Creature::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Creature::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Creature::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Creature::release_name() {
  // @@protoc_insertion_point(field_release:server.Creature.name)
  return _impl_.name_.Release();
}
inline void Creature::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Creature.name)
}

// .google.protobuf.Timestamp last_updated = 3;
inline bool Creature::_internal_has_last_updated() const {
  return this != internal_default_instance() && _impl_.last_updated_ != nullptr;
}
inline bool Creature::has_last_updated() const {
  return _internal_has_last_updated();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Creature::_internal_last_updated() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.last_updated_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& Creature::last_updated() const {
  // @@protoc_insertion_point(field_get:server.Creature.last_updated)
  return _internal_last_updated();
}
inline void Creature::unsafe_arena_set_allocated_last_updated(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_updated_);
  }
  _impl_.last_updated_ = last_updated;
  if (last_updated) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:server.Creature.last_updated)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Creature::release_last_updated() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_updated_;
  _impl_.last_updated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Creature::unsafe_arena_release_last_updated() {
  // @@protoc_insertion_point(field_release:server.Creature.last_updated)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.last_updated_;
  _impl_.last_updated_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Creature::_internal_mutable_last_updated() {
  
  if (_impl_.last_updated_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.last_updated_ = p;
  }
  return _impl_.last_updated_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* Creature::mutable_last_updated() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_updated();
  // @@protoc_insertion_point(field_mutable:server.Creature.last_updated)
  return _msg;
}
inline void Creature::set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.last_updated_);
  }
  if (last_updated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated));
    if (message_arena != submessage_arena) {
      last_updated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_updated, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.last_updated_ = last_updated;
  // @@protoc_insertion_point(field_set_allocated:server.Creature.last_updated)
}

// string sacn_ip = 4;
inline void Creature::clear_sacn_ip() {
  _impl_.sacn_ip_.ClearToEmpty();
}
inline const std::string& Creature::sacn_ip() const {
  // @@protoc_insertion_point(field_get:server.Creature.sacn_ip)
  return _internal_sacn_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Creature::set_sacn_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sacn_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Creature.sacn_ip)
}
inline std::string* Creature::mutable_sacn_ip() {
  std::string* _s = _internal_mutable_sacn_ip();
  // @@protoc_insertion_point(field_mutable:server.Creature.sacn_ip)
  return _s;
}
inline const std::string& Creature::_internal_sacn_ip() const {
  return _impl_.sacn_ip_.Get();
}
inline void Creature::_internal_set_sacn_ip(const std::string& value) {
  
  _impl_.sacn_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Creature::_internal_mutable_sacn_ip() {
  
  return _impl_.sacn_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* Creature::release_sacn_ip() {
  // @@protoc_insertion_point(field_release:server.Creature.sacn_ip)
  return _impl_.sacn_ip_.Release();
}
inline void Creature::set_allocated_sacn_ip(std::string* sacn_ip) {
  if (sacn_ip != nullptr) {
    
  } else {
    
  }
  _impl_.sacn_ip_.SetAllocated(sacn_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sacn_ip_.IsDefault()) {
    _impl_.sacn_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Creature.sacn_ip)
}

// uint32 universe = 5;
inline void Creature::clear_universe() {
  _impl_.universe_ = 0u;
}
inline uint32_t Creature::_internal_universe() const {
  return _impl_.universe_;
}
inline uint32_t Creature::universe() const {
  // @@protoc_insertion_point(field_get:server.Creature.universe)
  return _internal_universe();
}
inline void Creature::_internal_set_universe(uint32_t value) {
  
  _impl_.universe_ = value;
}
inline void Creature::set_universe(uint32_t value) {
  _internal_set_universe(value);
  // @@protoc_insertion_point(field_set:server.Creature.universe)
}

// uint32 dmx_base = 6;
inline void Creature::clear_dmx_base() {
  _impl_.dmx_base_ = 0u;
}
inline uint32_t Creature::_internal_dmx_base() const {
  return _impl_.dmx_base_;
}
inline uint32_t Creature::dmx_base() const {
  // @@protoc_insertion_point(field_get:server.Creature.dmx_base)
  return _internal_dmx_base();
}
inline void Creature::_internal_set_dmx_base(uint32_t value) {
  
  _impl_.dmx_base_ = value;
}
inline void Creature::set_dmx_base(uint32_t value) {
  _internal_set_dmx_base(value);
  // @@protoc_insertion_point(field_set:server.Creature.dmx_base)
}

// uint32 number_of_motors = 7;
inline void Creature::clear_number_of_motors() {
  _impl_.number_of_motors_ = 0u;
}
inline uint32_t Creature::_internal_number_of_motors() const {
  return _impl_.number_of_motors_;
}
inline uint32_t Creature::number_of_motors() const {
  // @@protoc_insertion_point(field_get:server.Creature.number_of_motors)
  return _internal_number_of_motors();
}
inline void Creature::_internal_set_number_of_motors(uint32_t value) {
  
  _impl_.number_of_motors_ = value;
}
inline void Creature::set_number_of_motors(uint32_t value) {
  _internal_set_number_of_motors(value);
  // @@protoc_insertion_point(field_set:server.Creature.number_of_motors)
}

// repeated .server.Creature.Motor motors = 8;
inline int Creature::_internal_motors_size() const {
  return _impl_.motors_.size();
}
inline int Creature::motors_size() const {
  return _internal_motors_size();
}
inline void Creature::clear_motors() {
  _impl_.motors_.Clear();
}
inline ::server::Creature_Motor* Creature::mutable_motors(int index) {
  // @@protoc_insertion_point(field_mutable:server.Creature.motors)
  return _impl_.motors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor >*
Creature::mutable_motors() {
  // @@protoc_insertion_point(field_mutable_list:server.Creature.motors)
  return &_impl_.motors_;
}
inline const ::server::Creature_Motor& Creature::_internal_motors(int index) const {
  return _impl_.motors_.Get(index);
}
inline const ::server::Creature_Motor& Creature::motors(int index) const {
  // @@protoc_insertion_point(field_get:server.Creature.motors)
  return _internal_motors(index);
}
inline ::server::Creature_Motor* Creature::_internal_add_motors() {
  return _impl_.motors_.Add();
}
inline ::server::Creature_Motor* Creature::add_motors() {
  ::server::Creature_Motor* _add = _internal_add_motors();
  // @@protoc_insertion_point(field_add:server.Creature.motors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::server::Creature_Motor >&
Creature::motors() const {
  // @@protoc_insertion_point(field_list:server.Creature.motors)
  return _impl_.motors_;
}

// -------------------------------------------------------------------

// LogLine

// .server.LogLevel level = 1;
inline void LogLine::clear_level() {
  _impl_.level_ = 0;
}
inline ::server::LogLevel LogLine::_internal_level() const {
  return static_cast< ::server::LogLevel >(_impl_.level_);
}
inline ::server::LogLevel LogLine::level() const {
  // @@protoc_insertion_point(field_get:server.LogLine.level)
  return _internal_level();
}
inline void LogLine::_internal_set_level(::server::LogLevel value) {
  
  _impl_.level_ = value;
}
inline void LogLine::set_level(::server::LogLevel value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:server.LogLine.level)
}

// .google.protobuf.Timestamp timestamp = 2;
inline bool LogLine::_internal_has_timestamp() const {
  return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool LogLine::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogLine::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& LogLine::timestamp() const {
  // @@protoc_insertion_point(field_get:server.LogLine.timestamp)
  return _internal_timestamp();
}
inline void LogLine::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  _impl_.timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:server.LogLine.timestamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogLine::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogLine::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:server.LogLine.timestamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.timestamp_;
  _impl_.timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogLine::_internal_mutable_timestamp() {
  
  if (_impl_.timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.timestamp_ = p;
  }
  return _impl_.timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* LogLine::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:server.LogLine.timestamp)
  return _msg;
}
inline void LogLine::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:server.LogLine.timestamp)
}

// string message = 3;
inline void LogLine::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& LogLine::message() const {
  // @@protoc_insertion_point(field_get:server.LogLine.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogLine::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.LogLine.message)
}
inline std::string* LogLine::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:server.LogLine.message)
  return _s;
}
inline const std::string& LogLine::_internal_message() const {
  return _impl_.message_.Get();
}
inline void LogLine::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* LogLine::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* LogLine::release_message() {
  // @@protoc_insertion_point(field_release:server.LogLine.message)
  return _impl_.message_.Release();
}
inline void LogLine::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.LogLine.message)
}

// -------------------------------------------------------------------

// Frame

// uint32 universe = 1;
inline void Frame::clear_universe() {
  _impl_.universe_ = 0u;
}
inline uint32_t Frame::_internal_universe() const {
  return _impl_.universe_;
}
inline uint32_t Frame::universe() const {
  // @@protoc_insertion_point(field_get:server.Frame.universe)
  return _internal_universe();
}
inline void Frame::_internal_set_universe(uint32_t value) {
  
  _impl_.universe_ = value;
}
inline void Frame::set_universe(uint32_t value) {
  _internal_set_universe(value);
  // @@protoc_insertion_point(field_set:server.Frame.universe)
}

// uint32 dmx_offset = 2;
inline void Frame::clear_dmx_offset() {
  _impl_.dmx_offset_ = 0u;
}
inline uint32_t Frame::_internal_dmx_offset() const {
  return _impl_.dmx_offset_;
}
inline uint32_t Frame::dmx_offset() const {
  // @@protoc_insertion_point(field_get:server.Frame.dmx_offset)
  return _internal_dmx_offset();
}
inline void Frame::_internal_set_dmx_offset(uint32_t value) {
  
  _impl_.dmx_offset_ = value;
}
inline void Frame::set_dmx_offset(uint32_t value) {
  _internal_set_dmx_offset(value);
  // @@protoc_insertion_point(field_set:server.Frame.dmx_offset)
}

// string creature_name = 3;
inline void Frame::clear_creature_name() {
  _impl_.creature_name_.ClearToEmpty();
}
inline const std::string& Frame::creature_name() const {
  // @@protoc_insertion_point(field_get:server.Frame.creature_name)
  return _internal_creature_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Frame::set_creature_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.creature_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Frame.creature_name)
}
inline std::string* Frame::mutable_creature_name() {
  std::string* _s = _internal_mutable_creature_name();
  // @@protoc_insertion_point(field_mutable:server.Frame.creature_name)
  return _s;
}
inline const std::string& Frame::_internal_creature_name() const {
  return _impl_.creature_name_.Get();
}
inline void Frame::_internal_set_creature_name(const std::string& value) {
  
  _impl_.creature_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Frame::_internal_mutable_creature_name() {
  
  return _impl_.creature_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Frame::release_creature_name() {
  // @@protoc_insertion_point(field_release:server.Frame.creature_name)
  return _impl_.creature_name_.Release();
}
inline void Frame::set_allocated_creature_name(std::string* creature_name) {
  if (creature_name != nullptr) {
    
  } else {
    
  }
  _impl_.creature_name_.SetAllocated(creature_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.creature_name_.IsDefault()) {
    _impl_.creature_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Frame.creature_name)
}

// string sacn_ip = 4;
inline void Frame::clear_sacn_ip() {
  _impl_.sacn_ip_.ClearToEmpty();
}
inline const std::string& Frame::sacn_ip() const {
  // @@protoc_insertion_point(field_get:server.Frame.sacn_ip)
  return _internal_sacn_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Frame::set_sacn_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sacn_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Frame.sacn_ip)
}
inline std::string* Frame::mutable_sacn_ip() {
  std::string* _s = _internal_mutable_sacn_ip();
  // @@protoc_insertion_point(field_mutable:server.Frame.sacn_ip)
  return _s;
}
inline const std::string& Frame::_internal_sacn_ip() const {
  return _impl_.sacn_ip_.Get();
}
inline void Frame::_internal_set_sacn_ip(const std::string& value) {
  
  _impl_.sacn_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* Frame::_internal_mutable_sacn_ip() {
  
  return _impl_.sacn_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* Frame::release_sacn_ip() {
  // @@protoc_insertion_point(field_release:server.Frame.sacn_ip)
  return _impl_.sacn_ip_.Release();
}
inline void Frame::set_allocated_sacn_ip(std::string* sacn_ip) {
  if (sacn_ip != nullptr) {
    
  } else {
    
  }
  _impl_.sacn_ip_.SetAllocated(sacn_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sacn_ip_.IsDefault()) {
    _impl_.sacn_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Frame.sacn_ip)
}

// bytes frame = 10;
inline void Frame::clear_frame() {
  _impl_.frame_.ClearToEmpty();
}
inline const std::string& Frame::frame() const {
  // @@protoc_insertion_point(field_get:server.Frame.frame)
  return _internal_frame();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Frame::set_frame(ArgT0&& arg0, ArgT... args) {
 
 _impl_.frame_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.Frame.frame)
}
inline std::string* Frame::mutable_frame() {
  std::string* _s = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:server.Frame.frame)
  return _s;
}
inline const std::string& Frame::_internal_frame() const {
  return _impl_.frame_.Get();
}
inline void Frame::_internal_set_frame(const std::string& value) {
  
  _impl_.frame_.Set(value, GetArenaForAllocation());
}
inline std::string* Frame::_internal_mutable_frame() {
  
  return _impl_.frame_.Mutable(GetArenaForAllocation());
}
inline std::string* Frame::release_frame() {
  // @@protoc_insertion_point(field_release:server.Frame.frame)
  return _impl_.frame_.Release();
}
inline void Frame::set_allocated_frame(std::string* frame) {
  if (frame != nullptr) {
    
  } else {
    
  }
  _impl_.frame_.SetAllocated(frame, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.frame_.IsDefault()) {
    _impl_.frame_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.Frame.frame)
}

// -------------------------------------------------------------------

// FrameResponse

// uint32 frames_processed = 1;
inline void FrameResponse::clear_frames_processed() {
  _impl_.frames_processed_ = 0u;
}
inline uint32_t FrameResponse::_internal_frames_processed() const {
  return _impl_.frames_processed_;
}
inline uint32_t FrameResponse::frames_processed() const {
  // @@protoc_insertion_point(field_get:server.FrameResponse.frames_processed)
  return _internal_frames_processed();
}
inline void FrameResponse::_internal_set_frames_processed(uint32_t value) {
  
  _impl_.frames_processed_ = value;
}
inline void FrameResponse::set_frames_processed(uint32_t value) {
  _internal_set_frames_processed(value);
  // @@protoc_insertion_point(field_set:server.FrameResponse.frames_processed)
}

// string message = 2;
inline void FrameResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& FrameResponse::message() const {
  // @@protoc_insertion_point(field_get:server.FrameResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FrameResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:server.FrameResponse.message)
}
inline std::string* FrameResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:server.FrameResponse.message)
  return _s;
}
inline const std::string& FrameResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void FrameResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* FrameResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* FrameResponse::release_message() {
  // @@protoc_insertion_point(field_release:server.FrameResponse.message)
  return _impl_.message_.Release();
}
inline void FrameResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:server.FrameResponse.message)
}

// -------------------------------------------------------------------

// ServerStatus

// uint64 frames_processed = 1;
inline void ServerStatus::clear_frames_processed() {
  _impl_.frames_processed_ = uint64_t{0u};
}
inline uint64_t ServerStatus::_internal_frames_processed() const {
  return _impl_.frames_processed_;
}
inline uint64_t ServerStatus::frames_processed() const {
  // @@protoc_insertion_point(field_get:server.ServerStatus.frames_processed)
  return _internal_frames_processed();
}
inline void ServerStatus::_internal_set_frames_processed(uint64_t value) {
  
  _impl_.frames_processed_ = value;
}
inline void ServerStatus::set_frames_processed(uint64_t value) {
  _internal_set_frames_processed(value);
  // @@protoc_insertion_point(field_set:server.ServerStatus.frames_processed)
}

// .google.protobuf.Timestamp started_at = 2;
inline bool ServerStatus::_internal_has_started_at() const {
  return this != internal_default_instance() && _impl_.started_at_ != nullptr;
}
inline bool ServerStatus::has_started_at() const {
  return _internal_has_started_at();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServerStatus::_internal_started_at() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = _impl_.started_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& ServerStatus::started_at() const {
  // @@protoc_insertion_point(field_get:server.ServerStatus.started_at)
  return _internal_started_at();
}
inline void ServerStatus::unsafe_arena_set_allocated_started_at(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.started_at_);
  }
  _impl_.started_at_ = started_at;
  if (started_at) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:server.ServerStatus.started_at)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServerStatus::release_started_at() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.started_at_;
  _impl_.started_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServerStatus::unsafe_arena_release_started_at() {
  // @@protoc_insertion_point(field_release:server.ServerStatus.started_at)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = _impl_.started_at_;
  _impl_.started_at_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServerStatus::_internal_mutable_started_at() {
  
  if (_impl_.started_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    _impl_.started_at_ = p;
  }
  return _impl_.started_at_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* ServerStatus::mutable_started_at() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_started_at();
  // @@protoc_insertion_point(field_mutable:server.ServerStatus.started_at)
  return _msg;
}
inline void ServerStatus::set_allocated_started_at(::PROTOBUF_NAMESPACE_ID::Timestamp* started_at) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.started_at_);
  }
  if (started_at) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(started_at));
    if (message_arena != submessage_arena) {
      started_at = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, started_at, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.started_at_ = started_at;
  // @@protoc_insertion_point(field_set_allocated:server.ServerStatus.started_at)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace server

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::server::Creature_MotorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server::Creature_MotorType>() {
  return ::server::Creature_MotorType_descriptor();
}
template <> struct is_proto_enum< ::server::LogLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server::LogLevel>() {
  return ::server::LogLevel_descriptor();
}
template <> struct is_proto_enum< ::server::SortBy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server::SortBy>() {
  return ::server::SortBy_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_server_2eproto
