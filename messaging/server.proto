syntax = "proto3";

option go_package = "opsnlops.io/creatures/server";
option java_multiple_files = true;
option java_package = "io.opsnlops.creatures.server";
option java_outer_classname = "NetworkServerProto";

option optimize_for = SPEED;

package server;

import public "google/protobuf/empty.proto";
import public "google/protobuf/timestamp.proto";

// TODO: This might be helpful later!
// import "google/protobuf/wrappers.proto";

service CreatureServer {

  // Fetches one from the database
  rpc GetCreature(CreatureId) returns (Creature) {}

  // Get all of them
  rpc GetAllCreatures(CreatureFilter) returns (GetAllCreaturesResponse) {}

  // Create a new creature in the database
  rpc CreateCreature(Creature) returns (DatabaseInfo) {}

  // Update an existing creature in the database
  rpc UpdateCreature(Creature) returns (DatabaseInfo) {}

  // Stream log messages from the server
  rpc StreamLogs(LogFilter) returns (stream LogItem) {}

  // Search for a Creature by name
  rpc SearchCreatures (CreatureName) returns (Creature) {}

  rpc ListCreatures(CreatureFilter) returns (ListCreaturesResponse) {}

  // Stream frames from the client to a Creature. Used for real time control, if
  // that's something I want to do.
  rpc StreamFrames(stream StreamFrameData) returns (StreamFrameDataResponse) {}

  rpc GetServerStatus(google.protobuf.Empty) returns (ServerStatus) {}

  /**
    Save a new animation in the database

    Defined in server/animation/database.cpp
   */
  rpc CreateAnimation(Animation) returns (DatabaseInfo) {}
  rpc UpdateAnimation(Animation) returns (DatabaseInfo) {}
  rpc GetAnimation(AnimationId) returns (Animation) {}
  rpc GetAnimationMetadata(AnimationId) returns (AnimationMetadata) {}


  /**
    Returns a list of the animations that match a filter
   */
  rpc ListAnimations(AnimationFilter) returns (ListAnimationsResponse) {}

  // Request that an animation get played on a creature
  rpc PlayAnimation(PlayAnimationRequest) returns (PlayAnimationResponse) {}


  // Play a sound file! Used mostly for testing, since PlayAnimation will
  // automatically play a sound if there is one in the animation.
  rpc PlaySound(PlaySoundRequest) returns (PlaySoundResponse) {}

  /**
    Playlists!
   */
  rpc CreatePlaylist(Playlist) returns (DatabaseInfo) {}
  rpc UpdatePlaylist(Playlist) returns (DatabaseInfo) {}
  rpc GetPlaylist(PlaylistIdentifier) returns (Playlist) {}
  rpc ListPlaylists(PlaylistFilter) returns (ListPlaylistsResponse) {}
  rpc StartPlaylist(CreaturePlaylistRequest) returns (CreaturePlaylistResponse) {}
  rpc StopPlaylist(CreatureId) returns (CreaturePlaylistResponse) {}
  rpc GetPlaylistStatus(CreatureId) returns (CreaturePlaylistStatus) {}

}

/*
    Used to populate the list of creatures
 */
message CreatureIdentifier {
  bytes _id = 1;
  string name = 2;
}

message ListCreaturesResponse {
  repeated CreatureIdentifier creaturesIds = 1;
}

message GetAllCreaturesResponse {
  repeated Creature creatures = 1;
}

message CreatureFilter {
  string filter = 1;
  SortBy sortBy = 2;
}

message DatabaseInfo {
  string message = 1;
  string help = 2;

}

message LogFilter {
  LogLevel level = 1;
}

message CreatureId {
  bytes _id = 1;
}

message CreatureName {
  string name = 1;
}

message Creature {
  bytes _id = 1;
  string name = 2;
  google.protobuf.Timestamp last_updated = 3;
  //uint32 universe = 5;      /* No, don't do this. I need to have dev and prod network */
  int32 channel_offset = 4;
  int32 audio_channel = 5;
  string notes = 6;
}


//log_clock::time_point log_time, source_loc loc, string_view_t logger_name, level::level_enum lvl, string_view_t msg);
//source_loc(const char *filename_in, int line_in, const char *funcname_in)
message LogItem {
    LogLevel level = 1;
    google.protobuf.Timestamp timestamp = 2;
    string message = 3;
    string logger_name = 4;
    uint32 thread_id = 5;
}

enum LogLevel {
  trace = 0;
  debug = 1;
  info = 2;
  warn = 3;
  error = 4;
  critical = 5;
  off = 6;
  unknown = 7;
}


enum SortBy {
  name = 0;
  number = 1;
}



/**
  One frame to send to a creature
 */
//message Frame {
//  uint32 universe = 1;
//  uint32 channel_offset = 2;
//  string creature_name = 3;
//  uint32 number_of_motors = 4;
//  bytes frame = 10;
//}



message ServerStatus {
  uint64 frames_processed = 1;
  google.protobuf.Timestamp started_at = 2;
  bool database_connected = 3;
}


/**
  Stream frames to a creature

  This is used for real time control of a creature from the console.

 */

// One frame to stream to the creature in the StreamFrameRequest. Offset is looked
// up in the database.
message StreamFrameData {
  bytes creature_id = 1;
  uint32 universe = 2;
  bytes data = 10;
}

message StreamFrameDataResponse {
  uint32 frames_processed = 1;
  string message = 2;
}







message AnimationId {
  bytes _id = 1;
}

/*
  Parameters for the ListAnimations request

  This is used to filter the list of animations that are returned.
 */
message AnimationFilter {
  CreatureId creature_id = 1;
}

message ListAnimationsResponse {
  repeated AnimationMetadata animations = 1;
}


/**
  Play an animation on a creature

  This plays an animation that's out of the database, on a given universe. The universe
  is allowed to be given so that I can have a dev and prod network on the same wire.

 */
message PlayAnimationRequest {
  AnimationId animationId = 1;
  uint32 universe = 2;
}

message PlayAnimationResponse {
  string status = 1;
  int32 number_of_frames_queued = 2;
}

message PlaySoundRequest {
  string fileName = 1;
}

message PlaySoundResponse {
  string message = 1;
}

/**
  Playlists are a list of animations to play

  These are used to have a creature do a loop of animations. The weight is the likelihood
  that one animation will be played, if it's being played randomly. The formula is:

   probability = weight / (sum of the weights)

 */
message PlaylistIdentifier {
  bytes _id = 1;
}

message Playlist {

  message PlaylistItem {
    AnimationId animationId = 1;
    int32 weight = 2;
  }

  PlaylistIdentifier _id = 1;
  string name = 2;
  google.protobuf.Timestamp last_updated = 3;

  // The actual items themselves
  repeated PlaylistItem items = 10;

}

message PlaylistFilter {
  SortBy sortBy = 1;
}

message ListPlaylistsResponse {
  repeated Playlist playlists = 1;
}

message CreaturePlaylistRequest {
  uint32             universe = 1;
  PlaylistIdentifier playlistId = 2;
}

message CreaturePlaylistResponse {
  bool   success = 1;
  string message = 2;
}

message CreaturePlaylistStatus {
  bool               playing = 1;
  PlaylistIdentifier playlistId = 2;
  uint32             universe = 3;
}



//
// Animations 2.0
//

/*
  Animations 2.0 is a different approach for animations. This new take is gives up
  the idea that one animation could be played on more than one creature. (I have figured
  out that that's not really a good idea.)

  Each creature involved in the animation will have its own set of frames, represented
  as a FrameData object. Each item in the FrameData object should have the same number of
  frames.

  Playing an animation is a lot more complex. The server needs to look up each creature in
  the animation to know which e1.31 frame offset to use. This allows me to move creatures
  around as needed, rather than being hard coded. I can also edit one creature's set of
  frames independently of the others.

 */

message Animation {
  // Unique ID
  bytes _id = 1;

  // Metadata
  AnimationMetadata metadata = 5;

  // Actual frame data
  repeated FrameData frames = 20;
}

/**
  Metadata for an animation

  This is the information that's displayed in the UI. It's a separate object so that we can get
  a list of the animations without having to load all of the frame data.

 */
message AnimationMetadata {

  /*
    The animation that we're connected to

    This is used to link the metadata to the actual frame data. It's kept like this
    so that we can link back to the frame data from the UI.

   */
  bytes animation_id = 1;

  // Title as it appears in the UI
  string title = 2;

  // Last time this was updated
  google.protobuf.Timestamp last_updated = 3;

  // Data pacing (almost always 20)
  uint32 milliseconds_per_frame = 4;

  // A note for myself in the UI
  string note = 5;

  // Sound file to play
  string sound_file = 6;

  // Number of frames that should be expected in each FrameData
  uint32 number_of_frames = 7;

  // Does this animation have more than one audio track?
  bool multitrack_audio = 8;
}



/**
  I considered embedding the FrameData in the Animation object, but I think it's better
  like this. It will make it easier to deal with in the application.
 */


//
// One creature's frames in an animation
//
message FrameData {

  // Unique ID
  bytes _id = 1;

  // The creature ID that this frame data is for
  bytes creature_id = 2;

  // Which animation ID is this data connected to for reference
  bytes animation_id = 3;

  // The actual frames
  repeated bytes frames = 20;
}